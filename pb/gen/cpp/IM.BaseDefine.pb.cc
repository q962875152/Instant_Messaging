// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#include "IM.BaseDefine.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace IM {
namespace BaseDefine {
constexpr IpAddr::IpAddr(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , port_(0u){}
struct IpAddrDefaultTypeInternal {
  constexpr IpAddrDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IpAddrDefaultTypeInternal() {}
  union {
    IpAddr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IpAddrDefaultTypeInternal _IpAddr_default_instance_;
constexpr UserInfo::UserInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_nick_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , avatar_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , email_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_real_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_tel_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_domain_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sign_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , user_gender_(0u)
  , department_id_(0u)
  , status_(0u){}
struct UserInfoDefaultTypeInternal {
  constexpr UserInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserInfoDefaultTypeInternal() {}
  union {
    UserInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserInfoDefaultTypeInternal _UserInfo_default_instance_;
constexpr ContactSessionInfo::ContactSessionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : latest_msg_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , session_id_(0u)
  , session_status_(0)

  , updated_time_(0u)
  , latest_msg_id_(0u)
  , latest_msg_from_user_id_(0u)
  , session_type_(1)

  , latest_msg_type_(1)
{}
struct ContactSessionInfoDefaultTypeInternal {
  constexpr ContactSessionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ContactSessionInfoDefaultTypeInternal() {}
  union {
    ContactSessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ContactSessionInfoDefaultTypeInternal _ContactSessionInfo_default_instance_;
constexpr UserStat::UserStat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , status_(1)
{}
struct UserStatDefaultTypeInternal {
  constexpr UserStatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserStatDefaultTypeInternal() {}
  union {
    UserStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserStatDefaultTypeInternal _UserStat_default_instance_;
constexpr ServerUserStat::ServerUserStat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , status_(1)

  , client_type_(1)
{}
struct ServerUserStatDefaultTypeInternal {
  constexpr ServerUserStatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServerUserStatDefaultTypeInternal() {}
  union {
    ServerUserStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServerUserStatDefaultTypeInternal _ServerUserStat_default_instance_;
constexpr UnreadInfo::UnreadInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : latest_msg_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , session_id_(0u)
  , unread_cnt_(0u)
  , latest_msg_id_(0u)
  , latest_msg_from_user_id_(0u)
  , session_type_(1)

  , latest_msg_type_(1)
{}
struct UnreadInfoDefaultTypeInternal {
  constexpr UnreadInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UnreadInfoDefaultTypeInternal() {}
  union {
    UnreadInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UnreadInfoDefaultTypeInternal _UnreadInfo_default_instance_;
constexpr MsgInfo::MsgInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : msg_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , msg_id_(0u)
  , from_session_id_(0u)
  , create_time_(0u)
  , msg_type_(1)
{}
struct MsgInfoDefaultTypeInternal {
  constexpr MsgInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MsgInfoDefaultTypeInternal() {}
  union {
    MsgInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
constexpr GroupVersionInfo::GroupVersionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : group_id_(0u)
  , version_(0u){}
struct GroupVersionInfoDefaultTypeInternal {
  constexpr GroupVersionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GroupVersionInfoDefaultTypeInternal() {}
  union {
    GroupVersionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GroupVersionInfoDefaultTypeInternal _GroupVersionInfo_default_instance_;
constexpr GroupInfo::GroupInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : group_member_list_()
  , group_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , group_avatar_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , group_id_(0u)
  , version_(0u)
  , group_creator_id_(0u)
  , shield_status_(0u)
  , group_type_(1)
{}
struct GroupInfoDefaultTypeInternal {
  constexpr GroupInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GroupInfoDefaultTypeInternal() {}
  union {
    GroupInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
constexpr UserTokenInfo::UserTokenInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , push_count_(0u)
  , push_type_(0u)
  , user_type_(1)
{}
struct UserTokenInfoDefaultTypeInternal {
  constexpr UserTokenInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserTokenInfoDefaultTypeInternal() {}
  union {
    UserTokenInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserTokenInfoDefaultTypeInternal _UserTokenInfo_default_instance_;
constexpr PushResult::PushResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , result_code_(0u){}
struct PushResultDefaultTypeInternal {
  constexpr PushResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PushResultDefaultTypeInternal() {}
  union {
    PushResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PushResultDefaultTypeInternal _PushResult_default_instance_;
constexpr ShieldStatus::ShieldStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , group_id_(0u)
  , shield_status_(0u){}
struct ShieldStatusDefaultTypeInternal {
  constexpr ShieldStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ShieldStatusDefaultTypeInternal() {}
  union {
    ShieldStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ShieldStatusDefaultTypeInternal _ShieldStatus_default_instance_;
constexpr OfflineFileInfo::OfflineFileInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : task_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , from_user_id_(0u)
  , file_size_(0u){}
struct OfflineFileInfoDefaultTypeInternal {
  constexpr OfflineFileInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OfflineFileInfoDefaultTypeInternal() {}
  union {
    OfflineFileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OfflineFileInfoDefaultTypeInternal _OfflineFileInfo_default_instance_;
constexpr DepartInfo::DepartInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dept_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , dept_id_(0u)
  , priority_(0u)
  , parent_dept_id_(0u)
  , dept_status_(0)
{}
struct DepartInfoDefaultTypeInternal {
  constexpr DepartInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DepartInfoDefaultTypeInternal() {}
  union {
    DepartInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DepartInfoDefaultTypeInternal _DepartInfo_default_instance_;
constexpr PushShieldStatus::PushShieldStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , shield_status_(0u){}
struct PushShieldStatusDefaultTypeInternal {
  constexpr PushShieldStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PushShieldStatusDefaultTypeInternal() {}
  union {
    PushShieldStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PushShieldStatusDefaultTypeInternal _PushShieldStatus_default_instance_;
}  // namespace BaseDefine
}  // namespace IM
namespace IM {
namespace BaseDefine {
bool ServiceID_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceID_strings[8] = {};

static const char ServiceID_names[] =
  "SID_BUDDY_LIST"
  "SID_FILE"
  "SID_GROUP"
  "SID_INTERNAL"
  "SID_LOGIN"
  "SID_MSG"
  "SID_OTHER"
  "SID_SWITCH_SERVICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceID_entries[] = {
  { {ServiceID_names + 0, 14}, 2 },
  { {ServiceID_names + 14, 8}, 5 },
  { {ServiceID_names + 22, 9}, 4 },
  { {ServiceID_names + 31, 12}, 8 },
  { {ServiceID_names + 43, 9}, 1 },
  { {ServiceID_names + 52, 7}, 3 },
  { {ServiceID_names + 59, 9}, 7 },
  { {ServiceID_names + 68, 18}, 6 },
};

static const int ServiceID_entries_by_number[] = {
  4, // 1 -> SID_LOGIN
  0, // 2 -> SID_BUDDY_LIST
  5, // 3 -> SID_MSG
  2, // 4 -> SID_GROUP
  1, // 5 -> SID_FILE
  7, // 6 -> SID_SWITCH_SERVICE
  6, // 7 -> SID_OTHER
  3, // 8 -> SID_INTERNAL
};

const std::string& ServiceID_Name(
    ServiceID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceID_entries,
          ServiceID_entries_by_number,
          8, ServiceID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceID_entries,
      ServiceID_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceID_strings[idx].get();
}
bool ServiceID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceID_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<ServiceID>(int_value);
  }
  return success;
}
bool LoginCmdID_IsValid(int value) {
  switch (value) {
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 265:
    case 266:
    case 267:
    case 268:
    case 269:
    case 270:
    case 271:
    case 272:
    case 273:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginCmdID_strings[17] = {};

static const char LoginCmdID_names[] =
  "CID_LOGIN_KICK_USER"
  "CID_LOGIN_REQ_DEVICETOKEN"
  "CID_LOGIN_REQ_KICKPCCLIENT"
  "CID_LOGIN_REQ_LOGINOUT"
  "CID_LOGIN_REQ_MSGSERVER"
  "CID_LOGIN_REQ_PUSH_SHIELD"
  "CID_LOGIN_REQ_QUERY_PUSH_SHIELD"
  "CID_LOGIN_REQ_REGIST"
  "CID_LOGIN_REQ_USERLOGIN"
  "CID_LOGIN_RES_DEVICETOKEN"
  "CID_LOGIN_RES_KICKPCCLIENT"
  "CID_LOGIN_RES_LOGINOUT"
  "CID_LOGIN_RES_MSGSERVER"
  "CID_LOGIN_RES_PUSH_SHIELD"
  "CID_LOGIN_RES_QUERY_PUSH_SHIELD"
  "CID_LOGIN_RES_REGIST"
  "CID_LOGIN_RES_USERLOGIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginCmdID_entries[] = {
  { {LoginCmdID_names + 0, 19}, 263 },
  { {LoginCmdID_names + 19, 25}, 264 },
  { {LoginCmdID_names + 44, 26}, 266 },
  { {LoginCmdID_names + 70, 22}, 261 },
  { {LoginCmdID_names + 92, 23}, 257 },
  { {LoginCmdID_names + 115, 25}, 268 },
  { {LoginCmdID_names + 140, 31}, 270 },
  { {LoginCmdID_names + 171, 20}, 272 },
  { {LoginCmdID_names + 191, 23}, 259 },
  { {LoginCmdID_names + 214, 25}, 265 },
  { {LoginCmdID_names + 239, 26}, 267 },
  { {LoginCmdID_names + 265, 22}, 262 },
  { {LoginCmdID_names + 287, 23}, 258 },
  { {LoginCmdID_names + 310, 25}, 269 },
  { {LoginCmdID_names + 335, 31}, 271 },
  { {LoginCmdID_names + 366, 20}, 273 },
  { {LoginCmdID_names + 386, 23}, 260 },
};

static const int LoginCmdID_entries_by_number[] = {
  4, // 257 -> CID_LOGIN_REQ_MSGSERVER
  12, // 258 -> CID_LOGIN_RES_MSGSERVER
  8, // 259 -> CID_LOGIN_REQ_USERLOGIN
  16, // 260 -> CID_LOGIN_RES_USERLOGIN
  3, // 261 -> CID_LOGIN_REQ_LOGINOUT
  11, // 262 -> CID_LOGIN_RES_LOGINOUT
  0, // 263 -> CID_LOGIN_KICK_USER
  1, // 264 -> CID_LOGIN_REQ_DEVICETOKEN
  9, // 265 -> CID_LOGIN_RES_DEVICETOKEN
  2, // 266 -> CID_LOGIN_REQ_KICKPCCLIENT
  10, // 267 -> CID_LOGIN_RES_KICKPCCLIENT
  5, // 268 -> CID_LOGIN_REQ_PUSH_SHIELD
  13, // 269 -> CID_LOGIN_RES_PUSH_SHIELD
  6, // 270 -> CID_LOGIN_REQ_QUERY_PUSH_SHIELD
  14, // 271 -> CID_LOGIN_RES_QUERY_PUSH_SHIELD
  7, // 272 -> CID_LOGIN_REQ_REGIST
  15, // 273 -> CID_LOGIN_RES_REGIST
};

const std::string& LoginCmdID_Name(
    LoginCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginCmdID_entries,
          LoginCmdID_entries_by_number,
          17, LoginCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginCmdID_entries,
      LoginCmdID_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginCmdID_strings[idx].get();
}
bool LoginCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginCmdID_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<LoginCmdID>(int_value);
  }
  return success;
}
bool BuddyListCmdID_IsValid(int value) {
  switch (value) {
    case 513:
    case 514:
    case 515:
    case 516:
    case 517:
    case 518:
    case 519:
    case 520:
    case 521:
    case 522:
    case 523:
    case 524:
    case 525:
    case 526:
    case 527:
    case 528:
    case 529:
    case 530:
    case 531:
    case 532:
    case 533:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BuddyListCmdID_strings[21] = {};

static const char BuddyListCmdID_names[] =
  "CID_BUDDY_LIST_ALL_USER_REQUEST"
  "CID_BUDDY_LIST_ALL_USER_RESPONSE"
  "CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY"
  "CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST"
  "CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE"
  "CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST"
  "CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE"
  "CID_BUDDY_LIST_DEPARTMENT_REQUEST"
  "CID_BUDDY_LIST_DEPARTMENT_RESPONSE"
  "CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY"
  "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST"
  "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE"
  "CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY"
  "CID_BUDDY_LIST_REMOVE_SESSION_REQ"
  "CID_BUDDY_LIST_REMOVE_SESSION_RES"
  "CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY"
  "CID_BUDDY_LIST_STATUS_NOTIFY"
  "CID_BUDDY_LIST_USERS_STATUS_REQUEST"
  "CID_BUDDY_LIST_USERS_STATUS_RESPONSE"
  "CID_BUDDY_LIST_USER_INFO_REQUEST"
  "CID_BUDDY_LIST_USER_INFO_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BuddyListCmdID_entries[] = {
  { {BuddyListCmdID_names + 0, 31}, 520 },
  { {BuddyListCmdID_names + 31, 32}, 521 },
  { {BuddyListCmdID_names + 63, 36}, 530 },
  { {BuddyListCmdID_names + 99, 36}, 524 },
  { {BuddyListCmdID_names + 135, 37}, 525 },
  { {BuddyListCmdID_names + 172, 39}, 531 },
  { {BuddyListCmdID_names + 211, 40}, 532 },
  { {BuddyListCmdID_names + 251, 33}, 528 },
  { {BuddyListCmdID_names + 284, 34}, 529 },
  { {BuddyListCmdID_names + 318, 37}, 526 },
  { {BuddyListCmdID_names + 355, 45}, 513 },
  { {BuddyListCmdID_names + 400, 46}, 514 },
  { {BuddyListCmdID_names + 446, 36}, 527 },
  { {BuddyListCmdID_names + 482, 33}, 518 },
  { {BuddyListCmdID_names + 515, 33}, 519 },
  { {BuddyListCmdID_names + 548, 39}, 533 },
  { {BuddyListCmdID_names + 587, 28}, 515 },
  { {BuddyListCmdID_names + 615, 35}, 522 },
  { {BuddyListCmdID_names + 650, 36}, 523 },
  { {BuddyListCmdID_names + 686, 32}, 516 },
  { {BuddyListCmdID_names + 718, 33}, 517 },
};

static const int BuddyListCmdID_entries_by_number[] = {
  10, // 513 -> CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST
  11, // 514 -> CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE
  16, // 515 -> CID_BUDDY_LIST_STATUS_NOTIFY
  19, // 516 -> CID_BUDDY_LIST_USER_INFO_REQUEST
  20, // 517 -> CID_BUDDY_LIST_USER_INFO_RESPONSE
  13, // 518 -> CID_BUDDY_LIST_REMOVE_SESSION_REQ
  14, // 519 -> CID_BUDDY_LIST_REMOVE_SESSION_RES
  0, // 520 -> CID_BUDDY_LIST_ALL_USER_REQUEST
  1, // 521 -> CID_BUDDY_LIST_ALL_USER_RESPONSE
  17, // 522 -> CID_BUDDY_LIST_USERS_STATUS_REQUEST
  18, // 523 -> CID_BUDDY_LIST_USERS_STATUS_RESPONSE
  3, // 524 -> CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST
  4, // 525 -> CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE
  9, // 526 -> CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY
  12, // 527 -> CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY
  7, // 528 -> CID_BUDDY_LIST_DEPARTMENT_REQUEST
  8, // 529 -> CID_BUDDY_LIST_DEPARTMENT_RESPONSE
  2, // 530 -> CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY
  5, // 531 -> CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST
  6, // 532 -> CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE
  15, // 533 -> CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY
};

const std::string& BuddyListCmdID_Name(
    BuddyListCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BuddyListCmdID_entries,
          BuddyListCmdID_entries_by_number,
          21, BuddyListCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BuddyListCmdID_entries,
      BuddyListCmdID_entries_by_number,
      21, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BuddyListCmdID_strings[idx].get();
}
bool BuddyListCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuddyListCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BuddyListCmdID_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<BuddyListCmdID>(int_value);
  }
  return success;
}
bool MessageCmdID_IsValid(int value) {
  switch (value) {
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MessageCmdID_strings[14] = {};

static const char MessageCmdID_names[] =
  "CID_MSG_DATA"
  "CID_MSG_DATA_ACK"
  "CID_MSG_GET_BY_MSG_ID_REQ"
  "CID_MSG_GET_BY_MSG_ID_RES"
  "CID_MSG_GET_LATEST_MSG_ID_REQ"
  "CID_MSG_GET_LATEST_MSG_ID_RSP"
  "CID_MSG_LIST_REQUEST"
  "CID_MSG_LIST_RESPONSE"
  "CID_MSG_READ_ACK"
  "CID_MSG_READ_NOTIFY"
  "CID_MSG_TIME_REQUEST"
  "CID_MSG_TIME_RESPONSE"
  "CID_MSG_UNREAD_CNT_REQUEST"
  "CID_MSG_UNREAD_CNT_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MessageCmdID_entries[] = {
  { {MessageCmdID_names + 0, 12}, 769 },
  { {MessageCmdID_names + 12, 16}, 770 },
  { {MessageCmdID_names + 28, 25}, 781 },
  { {MessageCmdID_names + 53, 25}, 782 },
  { {MessageCmdID_names + 78, 29}, 779 },
  { {MessageCmdID_names + 107, 29}, 780 },
  { {MessageCmdID_names + 136, 20}, 777 },
  { {MessageCmdID_names + 156, 21}, 778 },
  { {MessageCmdID_names + 177, 16}, 771 },
  { {MessageCmdID_names + 193, 19}, 772 },
  { {MessageCmdID_names + 212, 20}, 773 },
  { {MessageCmdID_names + 232, 21}, 774 },
  { {MessageCmdID_names + 253, 26}, 775 },
  { {MessageCmdID_names + 279, 27}, 776 },
};

static const int MessageCmdID_entries_by_number[] = {
  0, // 769 -> CID_MSG_DATA
  1, // 770 -> CID_MSG_DATA_ACK
  8, // 771 -> CID_MSG_READ_ACK
  9, // 772 -> CID_MSG_READ_NOTIFY
  10, // 773 -> CID_MSG_TIME_REQUEST
  11, // 774 -> CID_MSG_TIME_RESPONSE
  12, // 775 -> CID_MSG_UNREAD_CNT_REQUEST
  13, // 776 -> CID_MSG_UNREAD_CNT_RESPONSE
  6, // 777 -> CID_MSG_LIST_REQUEST
  7, // 778 -> CID_MSG_LIST_RESPONSE
  4, // 779 -> CID_MSG_GET_LATEST_MSG_ID_REQ
  5, // 780 -> CID_MSG_GET_LATEST_MSG_ID_RSP
  2, // 781 -> CID_MSG_GET_BY_MSG_ID_REQ
  3, // 782 -> CID_MSG_GET_BY_MSG_ID_RES
};

const std::string& MessageCmdID_Name(
    MessageCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MessageCmdID_entries,
          MessageCmdID_entries_by_number,
          14, MessageCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MessageCmdID_entries,
      MessageCmdID_entries_by_number,
      14, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MessageCmdID_strings[idx].get();
}
bool MessageCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MessageCmdID_entries, 14, name, &int_value);
  if (success) {
    *value = static_cast<MessageCmdID>(int_value);
  }
  return success;
}
bool GroupCmdID_IsValid(int value) {
  switch (value) {
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupCmdID_strings[11] = {};

static const char GroupCmdID_names[] =
  "CID_GROUP_CHANGE_MEMBER_NOTIFY"
  "CID_GROUP_CHANGE_MEMBER_REQUEST"
  "CID_GROUP_CHANGE_MEMBER_RESPONSE"
  "CID_GROUP_CREATE_REQUEST"
  "CID_GROUP_CREATE_RESPONSE"
  "CID_GROUP_INFO_REQUEST"
  "CID_GROUP_INFO_RESPONSE"
  "CID_GROUP_NORMAL_LIST_REQUEST"
  "CID_GROUP_NORMAL_LIST_RESPONSE"
  "CID_GROUP_SHIELD_GROUP_REQUEST"
  "CID_GROUP_SHIELD_GROUP_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupCmdID_entries[] = {
  { {GroupCmdID_names + 0, 30}, 1035 },
  { {GroupCmdID_names + 30, 31}, 1031 },
  { {GroupCmdID_names + 61, 32}, 1032 },
  { {GroupCmdID_names + 93, 24}, 1029 },
  { {GroupCmdID_names + 117, 25}, 1030 },
  { {GroupCmdID_names + 142, 22}, 1027 },
  { {GroupCmdID_names + 164, 23}, 1028 },
  { {GroupCmdID_names + 187, 29}, 1025 },
  { {GroupCmdID_names + 216, 30}, 1026 },
  { {GroupCmdID_names + 246, 30}, 1033 },
  { {GroupCmdID_names + 276, 31}, 1034 },
};

static const int GroupCmdID_entries_by_number[] = {
  7, // 1025 -> CID_GROUP_NORMAL_LIST_REQUEST
  8, // 1026 -> CID_GROUP_NORMAL_LIST_RESPONSE
  5, // 1027 -> CID_GROUP_INFO_REQUEST
  6, // 1028 -> CID_GROUP_INFO_RESPONSE
  3, // 1029 -> CID_GROUP_CREATE_REQUEST
  4, // 1030 -> CID_GROUP_CREATE_RESPONSE
  1, // 1031 -> CID_GROUP_CHANGE_MEMBER_REQUEST
  2, // 1032 -> CID_GROUP_CHANGE_MEMBER_RESPONSE
  9, // 1033 -> CID_GROUP_SHIELD_GROUP_REQUEST
  10, // 1034 -> CID_GROUP_SHIELD_GROUP_RESPONSE
  0, // 1035 -> CID_GROUP_CHANGE_MEMBER_NOTIFY
};

const std::string& GroupCmdID_Name(
    GroupCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupCmdID_entries,
          GroupCmdID_entries_by_number,
          11, GroupCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupCmdID_entries,
      GroupCmdID_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupCmdID_strings[idx].get();
}
bool GroupCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupCmdID_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<GroupCmdID>(int_value);
  }
  return success;
}
bool FileCmdID_IsValid(int value) {
  switch (value) {
    case 1281:
    case 1282:
    case 1283:
    case 1284:
    case 1285:
    case 1286:
    case 1287:
    case 1288:
    case 1289:
    case 1290:
    case 1291:
    case 1292:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileCmdID_strings[12] = {};

static const char FileCmdID_names[] =
  "CID_FILE_ADD_OFFLINE_REQ"
  "CID_FILE_DEL_OFFLINE_REQ"
  "CID_FILE_HAS_OFFLINE_REQ"
  "CID_FILE_HAS_OFFLINE_RES"
  "CID_FILE_LOGIN_REQ"
  "CID_FILE_LOGIN_RES"
  "CID_FILE_NOTIFY"
  "CID_FILE_PULL_DATA_REQ"
  "CID_FILE_PULL_DATA_RSP"
  "CID_FILE_REQUEST"
  "CID_FILE_RESPONSE"
  "CID_FILE_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileCmdID_entries[] = {
  { {FileCmdID_names + 0, 24}, 1291 },
  { {FileCmdID_names + 24, 24}, 1292 },
  { {FileCmdID_names + 48, 24}, 1289 },
  { {FileCmdID_names + 72, 24}, 1290 },
  { {FileCmdID_names + 96, 18}, 1281 },
  { {FileCmdID_names + 114, 18}, 1282 },
  { {FileCmdID_names + 132, 15}, 1288 },
  { {FileCmdID_names + 147, 22}, 1284 },
  { {FileCmdID_names + 169, 22}, 1285 },
  { {FileCmdID_names + 191, 16}, 1286 },
  { {FileCmdID_names + 207, 17}, 1287 },
  { {FileCmdID_names + 224, 14}, 1283 },
};

static const int FileCmdID_entries_by_number[] = {
  4, // 1281 -> CID_FILE_LOGIN_REQ
  5, // 1282 -> CID_FILE_LOGIN_RES
  11, // 1283 -> CID_FILE_STATE
  7, // 1284 -> CID_FILE_PULL_DATA_REQ
  8, // 1285 -> CID_FILE_PULL_DATA_RSP
  9, // 1286 -> CID_FILE_REQUEST
  10, // 1287 -> CID_FILE_RESPONSE
  6, // 1288 -> CID_FILE_NOTIFY
  2, // 1289 -> CID_FILE_HAS_OFFLINE_REQ
  3, // 1290 -> CID_FILE_HAS_OFFLINE_RES
  0, // 1291 -> CID_FILE_ADD_OFFLINE_REQ
  1, // 1292 -> CID_FILE_DEL_OFFLINE_REQ
};

const std::string& FileCmdID_Name(
    FileCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileCmdID_entries,
          FileCmdID_entries_by_number,
          12, FileCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileCmdID_entries,
      FileCmdID_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileCmdID_strings[idx].get();
}
bool FileCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileCmdID_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<FileCmdID>(int_value);
  }
  return success;
}
bool SwitchServiceCmdID_IsValid(int value) {
  switch (value) {
    case 1537:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SwitchServiceCmdID_strings[1] = {};

static const char SwitchServiceCmdID_names[] =
  "CID_SWITCH_P2P_CMD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SwitchServiceCmdID_entries[] = {
  { {SwitchServiceCmdID_names + 0, 18}, 1537 },
};

static const int SwitchServiceCmdID_entries_by_number[] = {
  0, // 1537 -> CID_SWITCH_P2P_CMD
};

const std::string& SwitchServiceCmdID_Name(
    SwitchServiceCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SwitchServiceCmdID_entries,
          SwitchServiceCmdID_entries_by_number,
          1, SwitchServiceCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SwitchServiceCmdID_entries,
      SwitchServiceCmdID_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SwitchServiceCmdID_strings[idx].get();
}
bool SwitchServiceCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwitchServiceCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SwitchServiceCmdID_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<SwitchServiceCmdID>(int_value);
  }
  return success;
}
bool OtherCmdID_IsValid(int value) {
  switch (value) {
    case 1793:
    case 1794:
    case 1795:
    case 1796:
    case 1797:
    case 1798:
    case 1799:
    case 1800:
    case 1801:
    case 1802:
    case 1803:
    case 1805:
    case 1806:
    case 1807:
    case 1808:
    case 1809:
    case 1810:
    case 1841:
    case 1842:
    case 1843:
    case 1844:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OtherCmdID_strings[21] = {};

static const char OtherCmdID_names[] =
  "CID_OTHER_FILE_SERVER_IP_REQ"
  "CID_OTHER_FILE_SERVER_IP_RSP"
  "CID_OTHER_FILE_TRANSFER_REQ"
  "CID_OTHER_FILE_TRANSFER_RSP"
  "CID_OTHER_GET_DEVICE_TOKEN_REQ"
  "CID_OTHER_GET_DEVICE_TOKEN_RSP"
  "CID_OTHER_GET_SHIELD_REQ"
  "CID_OTHER_GET_SHIELD_RSP"
  "CID_OTHER_HEARTBEAT"
  "CID_OTHER_LOGIN_STATUS_NOTIFY"
  "CID_OTHER_MSG_SERV_INFO"
  "CID_OTHER_ONLINE_USER_INFO"
  "CID_OTHER_PUSH_TO_USER_REQ"
  "CID_OTHER_PUSH_TO_USER_RSP"
  "CID_OTHER_ROLE_SET"
  "CID_OTHER_SERVER_KICK_USER"
  "CID_OTHER_STOP_RECV_PACKET"
  "CID_OTHER_USER_CNT_UPDATE"
  "CID_OTHER_USER_STATUS_UPDATE"
  "CID_OTHER_VALIDATE_REQ"
  "CID_OTHER_VALIDATE_RSP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OtherCmdID_entries[] = {
  { {OtherCmdID_names + 0, 28}, 1843 },
  { {OtherCmdID_names + 28, 28}, 1844 },
  { {OtherCmdID_names + 56, 27}, 1841 },
  { {OtherCmdID_names + 83, 27}, 1842 },
  { {OtherCmdID_names + 110, 30}, 1797 },
  { {OtherCmdID_names + 140, 30}, 1798 },
  { {OtherCmdID_names + 170, 24}, 1809 },
  { {OtherCmdID_names + 194, 24}, 1810 },
  { {OtherCmdID_names + 218, 19}, 1793 },
  { {OtherCmdID_names + 237, 29}, 1806 },
  { {OtherCmdID_names + 266, 23}, 1801 },
  { {OtherCmdID_names + 289, 26}, 1800 },
  { {OtherCmdID_names + 315, 26}, 1807 },
  { {OtherCmdID_names + 341, 26}, 1808 },
  { {OtherCmdID_names + 367, 18}, 1799 },
  { {OtherCmdID_names + 385, 26}, 1805 },
  { {OtherCmdID_names + 411, 26}, 1794 },
  { {OtherCmdID_names + 437, 25}, 1803 },
  { {OtherCmdID_names + 462, 28}, 1802 },
  { {OtherCmdID_names + 490, 22}, 1795 },
  { {OtherCmdID_names + 512, 22}, 1796 },
};

static const int OtherCmdID_entries_by_number[] = {
  8, // 1793 -> CID_OTHER_HEARTBEAT
  16, // 1794 -> CID_OTHER_STOP_RECV_PACKET
  19, // 1795 -> CID_OTHER_VALIDATE_REQ
  20, // 1796 -> CID_OTHER_VALIDATE_RSP
  4, // 1797 -> CID_OTHER_GET_DEVICE_TOKEN_REQ
  5, // 1798 -> CID_OTHER_GET_DEVICE_TOKEN_RSP
  14, // 1799 -> CID_OTHER_ROLE_SET
  11, // 1800 -> CID_OTHER_ONLINE_USER_INFO
  10, // 1801 -> CID_OTHER_MSG_SERV_INFO
  18, // 1802 -> CID_OTHER_USER_STATUS_UPDATE
  17, // 1803 -> CID_OTHER_USER_CNT_UPDATE
  15, // 1805 -> CID_OTHER_SERVER_KICK_USER
  9, // 1806 -> CID_OTHER_LOGIN_STATUS_NOTIFY
  12, // 1807 -> CID_OTHER_PUSH_TO_USER_REQ
  13, // 1808 -> CID_OTHER_PUSH_TO_USER_RSP
  6, // 1809 -> CID_OTHER_GET_SHIELD_REQ
  7, // 1810 -> CID_OTHER_GET_SHIELD_RSP
  2, // 1841 -> CID_OTHER_FILE_TRANSFER_REQ
  3, // 1842 -> CID_OTHER_FILE_TRANSFER_RSP
  0, // 1843 -> CID_OTHER_FILE_SERVER_IP_REQ
  1, // 1844 -> CID_OTHER_FILE_SERVER_IP_RSP
};

const std::string& OtherCmdID_Name(
    OtherCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OtherCmdID_entries,
          OtherCmdID_entries_by_number,
          21, OtherCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OtherCmdID_entries,
      OtherCmdID_entries_by_number,
      21, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OtherCmdID_strings[idx].get();
}
bool OtherCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OtherCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OtherCmdID_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<OtherCmdID>(int_value);
  }
  return success;
}
bool ResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResultType_strings[8] = {};

static const char ResultType_names[] =
  "REFUSE_REASON_DB_VALIDATE_FAILED"
  "REFUSE_REASON_MSG_SERVER_FULL"
  "REFUSE_REASON_NONE"
  "REFUSE_REASON_NO_DB_SERVER"
  "REFUSE_REASON_NO_LOGIN_SERVER"
  "REFUSE_REASON_NO_MSG_SERVER"
  "REFUSE_REASON_NO_ROUTE_SERVER"
  "REFUSE_REASON_VERSION_TOO_OLD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResultType_entries[] = {
  { {ResultType_names + 0, 32}, 6 },
  { {ResultType_names + 32, 29}, 2 },
  { {ResultType_names + 61, 18}, 0 },
  { {ResultType_names + 79, 26}, 3 },
  { {ResultType_names + 105, 29}, 4 },
  { {ResultType_names + 134, 27}, 1 },
  { {ResultType_names + 161, 29}, 5 },
  { {ResultType_names + 190, 29}, 7 },
};

static const int ResultType_entries_by_number[] = {
  2, // 0 -> REFUSE_REASON_NONE
  5, // 1 -> REFUSE_REASON_NO_MSG_SERVER
  1, // 2 -> REFUSE_REASON_MSG_SERVER_FULL
  3, // 3 -> REFUSE_REASON_NO_DB_SERVER
  4, // 4 -> REFUSE_REASON_NO_LOGIN_SERVER
  6, // 5 -> REFUSE_REASON_NO_ROUTE_SERVER
  0, // 6 -> REFUSE_REASON_DB_VALIDATE_FAILED
  7, // 7 -> REFUSE_REASON_VERSION_TOO_OLD
};

const std::string& ResultType_Name(
    ResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResultType_entries,
          ResultType_entries_by_number,
          8, ResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResultType_entries,
      ResultType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResultType_strings[idx].get();
}
bool ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResultType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<ResultType>(int_value);
  }
  return success;
}
bool KickReasonType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KickReasonType_strings[2] = {};

static const char KickReasonType_names[] =
  "KICK_REASON_DUPLICATE_USER"
  "KICK_REASON_MOBILE_KICK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KickReasonType_entries[] = {
  { {KickReasonType_names + 0, 26}, 1 },
  { {KickReasonType_names + 26, 23}, 2 },
};

static const int KickReasonType_entries_by_number[] = {
  0, // 1 -> KICK_REASON_DUPLICATE_USER
  1, // 2 -> KICK_REASON_MOBILE_KICK
};

const std::string& KickReasonType_Name(
    KickReasonType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KickReasonType_entries,
          KickReasonType_entries_by_number,
          2, KickReasonType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KickReasonType_entries,
      KickReasonType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KickReasonType_strings[idx].get();
}
bool KickReasonType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KickReasonType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KickReasonType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<KickReasonType>(int_value);
  }
  return success;
}
bool OnlineListType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OnlineListType_strings[1] = {};

static const char OnlineListType_names[] =
  "ONLINE_LIST_TYPE_FRIEND_LIST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OnlineListType_entries[] = {
  { {OnlineListType_names + 0, 28}, 1 },
};

static const int OnlineListType_entries_by_number[] = {
  0, // 1 -> ONLINE_LIST_TYPE_FRIEND_LIST
};

const std::string& OnlineListType_Name(
    OnlineListType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OnlineListType_entries,
          OnlineListType_entries_by_number,
          1, OnlineListType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OnlineListType_entries,
      OnlineListType_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OnlineListType_strings[idx].get();
}
bool OnlineListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OnlineListType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OnlineListType_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<OnlineListType>(int_value);
  }
  return success;
}
bool UserStatType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserStatType_strings[3] = {};

static const char UserStatType_names[] =
  "USER_STATUS_LEAVE"
  "USER_STATUS_OFFLINE"
  "USER_STATUS_ONLINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserStatType_entries[] = {
  { {UserStatType_names + 0, 17}, 3 },
  { {UserStatType_names + 17, 19}, 2 },
  { {UserStatType_names + 36, 18}, 1 },
};

static const int UserStatType_entries_by_number[] = {
  2, // 1 -> USER_STATUS_ONLINE
  1, // 2 -> USER_STATUS_OFFLINE
  0, // 3 -> USER_STATUS_LEAVE
};

const std::string& UserStatType_Name(
    UserStatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserStatType_entries,
          UserStatType_entries_by_number,
          3, UserStatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserStatType_entries,
      UserStatType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserStatType_strings[idx].get();
}
bool UserStatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserStatType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<UserStatType>(int_value);
  }
  return success;
}
bool SessionType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionType_strings[2] = {};

static const char SessionType_names[] =
  "SESSION_TYPE_GROUP"
  "SESSION_TYPE_SINGLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionType_entries[] = {
  { {SessionType_names + 0, 18}, 2 },
  { {SessionType_names + 18, 19}, 1 },
};

static const int SessionType_entries_by_number[] = {
  1, // 1 -> SESSION_TYPE_SINGLE
  0, // 2 -> SESSION_TYPE_GROUP
};

const std::string& SessionType_Name(
    SessionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionType_entries,
          SessionType_entries_by_number,
          2, SessionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionType_entries,
      SessionType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionType_strings[idx].get();
}
bool SessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SessionType>(int_value);
  }
  return success;
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MsgType_strings[4] = {};

static const char MsgType_names[] =
  "MSG_TYPE_GROUP_AUDIO"
  "MSG_TYPE_GROUP_TEXT"
  "MSG_TYPE_SINGLE_AUDIO"
  "MSG_TYPE_SINGLE_TEXT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MsgType_entries[] = {
  { {MsgType_names + 0, 20}, 18 },
  { {MsgType_names + 20, 19}, 17 },
  { {MsgType_names + 39, 21}, 2 },
  { {MsgType_names + 60, 20}, 1 },
};

static const int MsgType_entries_by_number[] = {
  3, // 1 -> MSG_TYPE_SINGLE_TEXT
  2, // 2 -> MSG_TYPE_SINGLE_AUDIO
  1, // 17 -> MSG_TYPE_GROUP_TEXT
  0, // 18 -> MSG_TYPE_GROUP_AUDIO
};

const std::string& MsgType_Name(
    MsgType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MsgType_entries,
          MsgType_entries_by_number,
          4, MsgType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MsgType_entries,
      MsgType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MsgType_strings[idx].get();
}
bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MsgType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<MsgType>(int_value);
  }
  return success;
}
bool ClientType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientType_strings[4] = {};

static const char ClientType_names[] =
  "CLIENT_TYPE_ANDROID"
  "CLIENT_TYPE_IOS"
  "CLIENT_TYPE_MAC"
  "CLIENT_TYPE_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientType_entries[] = {
  { {ClientType_names + 0, 19}, 18 },
  { {ClientType_names + 19, 15}, 17 },
  { {ClientType_names + 34, 15}, 2 },
  { {ClientType_names + 49, 19}, 1 },
};

static const int ClientType_entries_by_number[] = {
  3, // 1 -> CLIENT_TYPE_WINDOWS
  2, // 2 -> CLIENT_TYPE_MAC
  1, // 17 -> CLIENT_TYPE_IOS
  0, // 18 -> CLIENT_TYPE_ANDROID
};

const std::string& ClientType_Name(
    ClientType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientType_entries,
          ClientType_entries_by_number,
          4, ClientType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientType_entries,
      ClientType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientType_strings[idx].get();
}
bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientType>(int_value);
  }
  return success;
}
bool GroupType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupType_strings[2] = {};

static const char GroupType_names[] =
  "GROUP_TYPE_NORMAL"
  "GROUP_TYPE_TMP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupType_entries[] = {
  { {GroupType_names + 0, 17}, 1 },
  { {GroupType_names + 17, 14}, 2 },
};

static const int GroupType_entries_by_number[] = {
  0, // 1 -> GROUP_TYPE_NORMAL
  1, // 2 -> GROUP_TYPE_TMP
};

const std::string& GroupType_Name(
    GroupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupType_entries,
          GroupType_entries_by_number,
          2, GroupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupType_entries,
      GroupType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupType_strings[idx].get();
}
bool GroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GroupType>(int_value);
  }
  return success;
}
bool GroupModifyType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupModifyType_strings[2] = {};

static const char GroupModifyType_names[] =
  "GROUP_MODIFY_TYPE_ADD"
  "GROUP_MODIFY_TYPE_DEL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupModifyType_entries[] = {
  { {GroupModifyType_names + 0, 21}, 1 },
  { {GroupModifyType_names + 21, 21}, 2 },
};

static const int GroupModifyType_entries_by_number[] = {
  0, // 1 -> GROUP_MODIFY_TYPE_ADD
  1, // 2 -> GROUP_MODIFY_TYPE_DEL
};

const std::string& GroupModifyType_Name(
    GroupModifyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupModifyType_entries,
          GroupModifyType_entries_by_number,
          2, GroupModifyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupModifyType_entries,
      GroupModifyType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupModifyType_strings[idx].get();
}
bool GroupModifyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupModifyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupModifyType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GroupModifyType>(int_value);
  }
  return success;
}
bool TransferFileType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TransferFileType_strings[2] = {};

static const char TransferFileType_names[] =
  "FILE_TYPE_OFFLINE"
  "FILE_TYPE_ONLINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TransferFileType_entries[] = {
  { {TransferFileType_names + 0, 17}, 2 },
  { {TransferFileType_names + 17, 16}, 1 },
};

static const int TransferFileType_entries_by_number[] = {
  1, // 1 -> FILE_TYPE_ONLINE
  0, // 2 -> FILE_TYPE_OFFLINE
};

const std::string& TransferFileType_Name(
    TransferFileType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TransferFileType_entries,
          TransferFileType_entries_by_number,
          2, TransferFileType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TransferFileType_entries,
      TransferFileType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TransferFileType_strings[idx].get();
}
bool TransferFileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransferFileType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TransferFileType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TransferFileType>(int_value);
  }
  return success;
}
bool ClientFileState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFileState_strings[4] = {};

static const char ClientFileState_names[] =
  "CLIENT_FILE_CANCEL"
  "CLIENT_FILE_DONE"
  "CLIENT_FILE_PEER_READY"
  "CLIENT_FILE_REFUSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFileState_entries[] = {
  { {ClientFileState_names + 0, 18}, 1 },
  { {ClientFileState_names + 18, 16}, 3 },
  { {ClientFileState_names + 34, 22}, 0 },
  { {ClientFileState_names + 56, 18}, 2 },
};

static const int ClientFileState_entries_by_number[] = {
  2, // 0 -> CLIENT_FILE_PEER_READY
  0, // 1 -> CLIENT_FILE_CANCEL
  3, // 2 -> CLIENT_FILE_REFUSE
  1, // 3 -> CLIENT_FILE_DONE
};

const std::string& ClientFileState_Name(
    ClientFileState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFileState_entries,
          ClientFileState_entries_by_number,
          4, ClientFileState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFileState_entries,
      ClientFileState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFileState_strings[idx].get();
}
bool ClientFileState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFileState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientFileState>(int_value);
  }
  return success;
}
bool ClientFileRole_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFileRole_strings[4] = {};

static const char ClientFileRole_names[] =
  "CLIENT_OFFLINE_DOWNLOAD"
  "CLIENT_OFFLINE_UPLOAD"
  "CLIENT_REALTIME_RECVER"
  "CLIENT_REALTIME_SENDER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFileRole_entries[] = {
  { {ClientFileRole_names + 0, 23}, 4 },
  { {ClientFileRole_names + 23, 21}, 3 },
  { {ClientFileRole_names + 44, 22}, 2 },
  { {ClientFileRole_names + 66, 22}, 1 },
};

static const int ClientFileRole_entries_by_number[] = {
  3, // 1 -> CLIENT_REALTIME_SENDER
  2, // 2 -> CLIENT_REALTIME_RECVER
  1, // 3 -> CLIENT_OFFLINE_UPLOAD
  0, // 4 -> CLIENT_OFFLINE_DOWNLOAD
};

const std::string& ClientFileRole_Name(
    ClientFileRole value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFileRole_entries,
          ClientFileRole_entries_by_number,
          4, ClientFileRole_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFileRole_entries,
      ClientFileRole_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFileRole_strings[idx].get();
}
bool ClientFileRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileRole* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFileRole_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientFileRole>(int_value);
  }
  return success;
}
bool FileServerError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileServerError_strings[13] = {};

static const char FileServerError_names[] =
  "FILE_SERVER_ERRNO_CREATE_TASK_ERROR"
  "FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR"
  "FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK"
  "FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN"
  "FILE_SERVER_ERRNO_OK"
  "FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_FINISHED"
  "FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER"
  "FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileServerError_entries[] = {
  { {FileServerError_names + 0, 35}, 2 },
  { {FileServerError_names + 35, 38}, 1 },
  { {FileServerError_names + 73, 39}, 4 },
  { {FileServerError_names + 112, 37}, 3 },
  { {FileServerError_names + 149, 20}, 0 },
  { {FileServerError_names + 169, 43}, 10 },
  { {FileServerError_names + 212, 36}, 12 },
  { {FileServerError_names + 248, 41}, 6 },
  { {FileServerError_names + 289, 39}, 7 },
  { {FileServerError_names + 328, 43}, 8 },
  { {FileServerError_names + 371, 50}, 9 },
  { {FileServerError_names + 421, 45}, 11 },
  { {FileServerError_names + 466, 48}, 5 },
};

static const int FileServerError_entries_by_number[] = {
  4, // 0 -> FILE_SERVER_ERRNO_OK
  1, // 1 -> FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR
  0, // 2 -> FILE_SERVER_ERRNO_CREATE_TASK_ERROR
  3, // 3 -> FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN
  2, // 4 -> FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK
  12, // 5 -> FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID
  7, // 6 -> FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER
  8, // 7 -> FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR
  9, // 8 -> FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR
  10, // 9 -> FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR
  5, // 10 -> FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR
  11, // 11 -> FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR
  6, // 12 -> FILE_SERVER_ERRNO_PULL_DATA_FINISHED
};

const std::string& FileServerError_Name(
    FileServerError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileServerError_entries,
          FileServerError_entries_by_number,
          13, FileServerError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileServerError_entries,
      FileServerError_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileServerError_strings[idx].get();
}
bool FileServerError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileServerError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileServerError_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<FileServerError>(int_value);
  }
  return success;
}
bool SessionStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionStatusType_strings[2] = {};

static const char SessionStatusType_names[] =
  "SESSION_STATUS_DELETE"
  "SESSION_STATUS_OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionStatusType_entries[] = {
  { {SessionStatusType_names + 0, 21}, 1 },
  { {SessionStatusType_names + 21, 17}, 0 },
};

static const int SessionStatusType_entries_by_number[] = {
  1, // 0 -> SESSION_STATUS_OK
  0, // 1 -> SESSION_STATUS_DELETE
};

const std::string& SessionStatusType_Name(
    SessionStatusType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionStatusType_entries,
          SessionStatusType_entries_by_number,
          2, SessionStatusType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionStatusType_entries,
      SessionStatusType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionStatusType_strings[idx].get();
}
bool SessionStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStatusType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionStatusType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SessionStatusType>(int_value);
  }
  return success;
}
bool DepartmentStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DepartmentStatusType_strings[2] = {};

static const char DepartmentStatusType_names[] =
  "DEPT_STATUS_DELETE"
  "DEPT_STATUS_OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DepartmentStatusType_entries[] = {
  { {DepartmentStatusType_names + 0, 18}, 1 },
  { {DepartmentStatusType_names + 18, 14}, 0 },
};

static const int DepartmentStatusType_entries_by_number[] = {
  1, // 0 -> DEPT_STATUS_OK
  0, // 1 -> DEPT_STATUS_DELETE
};

const std::string& DepartmentStatusType_Name(
    DepartmentStatusType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DepartmentStatusType_entries,
          DepartmentStatusType_entries_by_number,
          2, DepartmentStatusType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DepartmentStatusType_entries,
      DepartmentStatusType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DepartmentStatusType_strings[idx].get();
}
bool DepartmentStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DepartmentStatusType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DepartmentStatusType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DepartmentStatusType>(int_value);
  }
  return success;
}

// ===================================================================

class IpAddr::_Internal {
 public:
  using HasBits = decltype(std::declval<IpAddr>()._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IpAddr::IpAddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.IpAddr)
}
IpAddr::IpAddr(const IpAddr& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArenaForAllocation());
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IpAddr)
}

inline void IpAddr::SharedCtor() {
ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_ = 0u;
}

IpAddr::~IpAddr() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IpAddr)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IpAddr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IpAddr::ArenaDtor(void* object) {
  IpAddr* _this = reinterpret_cast< IpAddr* >(object);
  (void)_this;
}
void IpAddr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IpAddr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IpAddr::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.IpAddr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ip_.ClearNonDefaultToEmpty();
  }
  port_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IpAddr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpAddr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.IpAddr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // required uint32 port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.IpAddr)
  return target;
}

size_t IpAddr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.IpAddr)
  size_t total_size = 0;

  if (_internal_has_ip()) {
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  if (_internal_has_port()) {
    // required uint32 port = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  return total_size;
}
size_t IpAddr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.IpAddr)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());

    // required uint32 port = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IpAddr::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IpAddr*>(
      &from));
}

void IpAddr::MergeFrom(const IpAddr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.IpAddr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      port_ = from.port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IpAddr::CopyFrom(const IpAddr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.IpAddr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpAddr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IpAddr::InternalSwap(IpAddr* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_, lhs_arena,
      &other->ip_, rhs_arena
  );
  swap(port_, other->port_);
}

std::string IpAddr::GetTypeName() const {
  return "IM.BaseDefine.IpAddr";
}


// ===================================================================

class UserInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserInfo>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_user_gender(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_user_nick_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_avatar_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_department_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_email(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_real_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_tel(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_user_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_sign_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000007bf) ^ 0x000007bf) != 0;
  }
};

UserInfo::UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserInfo)
}
UserInfo::UserInfo(const UserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  user_nick_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_nick_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_nick_name()) {
    user_nick_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_nick_name(), 
      GetArenaForAllocation());
  }
  avatar_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar_url()) {
    avatar_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatar_url(), 
      GetArenaForAllocation());
  }
  email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_email()) {
    email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_email(), 
      GetArenaForAllocation());
  }
  user_real_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_real_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_real_name()) {
    user_real_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_real_name(), 
      GetArenaForAllocation());
  }
  user_tel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_tel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_tel()) {
    user_tel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_tel(), 
      GetArenaForAllocation());
  }
  user_domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_domain()) {
    user_domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_domain(), 
      GetArenaForAllocation());
  }
  sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sign_info()) {
    sign_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sign_info(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserInfo)
}

inline void UserInfo::SharedCtor() {
user_nick_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_nick_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
avatar_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_real_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_real_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_tel_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_tel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(status_));
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UserInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_nick_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  avatar_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  email_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_real_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_tel_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_domain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sign_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UserInfo::ArenaDtor(void* object) {
  UserInfo* _this = reinterpret_cast< UserInfo* >(object);
  (void)_this;
}
void UserInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      user_nick_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      avatar_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      email_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      user_real_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      user_tel_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      user_domain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      sign_info_.ClearNonDefaultToEmpty();
    }
  }
  user_id_ = 0u;
  if (cached_has_bits & 0x00000700u) {
    ::memset(&user_gender_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&user_gender_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 user_gender = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_gender(&has_bits);
          user_gender_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_nick_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_nick_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string avatar_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_avatar_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 department_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_department_id(&has_bits);
          department_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string email = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_email();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_real_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_user_real_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_tel = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_user_tel();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_domain = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_user_domain();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 status = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sign_info = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_sign_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 user_gender = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_gender(), target);
  }

  // required string user_nick_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_nick_name(), target);
  }

  // required string avatar_url = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_avatar_url(), target);
  }

  // required uint32 department_id = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_department_id(), target);
  }

  // required string email = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_email(), target);
  }

  // required string user_real_name = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_user_real_name(), target);
  }

  // required string user_tel = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_user_tel(), target);
  }

  // required string user_domain = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_user_domain(), target);
  }

  // required uint32 status = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_status(), target);
  }

  // optional string sign_info = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_sign_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserInfo)
  return target;
}

size_t UserInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.UserInfo)
  size_t total_size = 0;

  if (_internal_has_user_nick_name()) {
    // required string user_nick_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_nick_name());
  }

  if (_internal_has_avatar_url()) {
    // required string avatar_url = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());
  }

  if (_internal_has_email()) {
    // required string email = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  if (_internal_has_user_real_name()) {
    // required string user_real_name = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_real_name());
  }

  if (_internal_has_user_tel()) {
    // required string user_tel = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_tel());
  }

  if (_internal_has_user_domain()) {
    // required string user_domain = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_domain());
  }

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_user_gender()) {
    // required uint32 user_gender = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_gender());
  }

  if (_internal_has_department_id()) {
    // required uint32 department_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_department_id());
  }

  if (_internal_has_status()) {
    // required uint32 status = 10;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
  }

  return total_size;
}
size_t UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000007bf) ^ 0x000007bf) == 0) {  // All required fields are present.
    // required string user_nick_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_nick_name());

    // required string avatar_url = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());

    // required string email = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());

    // required string user_real_name = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_real_name());

    // required string user_tel = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_tel());

    // required string user_domain = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_domain());

    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 user_gender = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_gender());

    // required uint32 department_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_department_id());

    // required uint32 status = 10;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string sign_info = 11;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000040u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sign_info());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UserInfo*>(
      &from));
}

void UserInfo::MergeFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_nick_name(from._internal_user_nick_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_avatar_url(from._internal_avatar_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_email(from._internal_email());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_user_real_name(from._internal_user_real_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_user_tel(from._internal_user_tel());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_user_domain(from._internal_user_domain());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_sign_info(from._internal_sign_info());
    }
    if (cached_has_bits & 0x00000080u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      user_gender_ = from.user_gender_;
    }
    if (cached_has_bits & 0x00000200u) {
      department_id_ = from.department_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserInfo::CopyFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UserInfo::InternalSwap(UserInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_nick_name_, lhs_arena,
      &other->user_nick_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatar_url_, lhs_arena,
      &other->avatar_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &email_, lhs_arena,
      &other->email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_real_name_, lhs_arena,
      &other->user_real_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_tel_, lhs_arena,
      &other->user_tel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_domain_, lhs_arena,
      &other->user_domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sign_info_, lhs_arena,
      &other->sign_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserInfo, status_)
      + sizeof(UserInfo::status_)
      - PROTOBUF_FIELD_OFFSET(UserInfo, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string UserInfo::GetTypeName() const {
  return "IM.BaseDefine.UserInfo";
}


// ===================================================================

class ContactSessionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ContactSessionInfo>()._has_bits_);
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_session_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_updated_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_latest_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_latest_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latest_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_latest_msg_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000ff) ^ 0x000000ff) != 0;
  }
};

ContactSessionInfo::ContactSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ContactSessionInfo)
}
ContactSessionInfo::ContactSessionInfo(const ContactSessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  latest_msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    latest_msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_latest_msg_data()) {
    latest_msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_latest_msg_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&session_id_, &from.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_msg_type_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ContactSessionInfo)
}

inline void ContactSessionInfo::SharedCtor() {
latest_msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  latest_msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&session_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_msg_from_user_id_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_from_user_id_));
session_type_ = 1;
latest_msg_type_ = 1;
}

ContactSessionInfo::~ContactSessionInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ContactSessionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ContactSessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  latest_msg_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ContactSessionInfo::ArenaDtor(void* object) {
  ContactSessionInfo* _this = reinterpret_cast< ContactSessionInfo* >(object);
  (void)_this;
}
void ContactSessionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ContactSessionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContactSessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ContactSessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    latest_msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_msg_from_user_id_) -
        reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_from_user_id_));
    session_type_ = 1;
    latest_msg_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContactSessionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_session_id(&has_bits);
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionStatusType session_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionStatusType_IsValid(val))) {
            _internal_set_session_status(static_cast<::IM::BaseDefine::SessionStatusType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 updated_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_updated_time(&has_bits);
          updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_latest_msg_id(&has_bits);
          latest_msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes latest_msg_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_latest_msg_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.MsgType latest_msg_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_latest_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_from_user_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_latest_msg_from_user_id(&has_bits);
          latest_msg_from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContactSessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ContactSessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 session_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // required .IM.BaseDefine.SessionStatusType session_status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_session_status(), target);
  }

  // required uint32 updated_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_updated_time(), target);
  }

  // required uint32 latest_msg_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_latest_msg_id(), target);
  }

  // required bytes latest_msg_data = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_latest_msg_data(), target);
  }

  // required .IM.BaseDefine.MsgType latest_msg_type = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_latest_msg_type(), target);
  }

  // required uint32 latest_msg_from_user_id = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_latest_msg_from_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ContactSessionInfo)
  return target;
}

size_t ContactSessionInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.ContactSessionInfo)
  size_t total_size = 0;

  if (_internal_has_latest_msg_data()) {
    // required bytes latest_msg_data = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_session_status()) {
    // required .IM.BaseDefine.SessionStatusType session_status = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_status());
  }

  if (_internal_has_updated_time()) {
    // required uint32 updated_time = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());
  }

  if (_internal_has_latest_msg_id()) {
    // required uint32 latest_msg_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());
  }

  if (_internal_has_latest_msg_from_user_id()) {
    // required uint32 latest_msg_from_user_id = 8;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());
  }

  if (_internal_has_session_type()) {
    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  if (_internal_has_latest_msg_type()) {
    // required .IM.BaseDefine.MsgType latest_msg_type = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_latest_msg_type());
  }

  return total_size;
}
size_t ContactSessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ContactSessionInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required bytes latest_msg_data = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());

    // required uint32 session_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required .IM.BaseDefine.SessionStatusType session_status = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_status());

    // required uint32 updated_time = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());

    // required uint32 latest_msg_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());

    // required uint32 latest_msg_from_user_id = 8;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());

    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());

    // required .IM.BaseDefine.MsgType latest_msg_type = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_latest_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContactSessionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ContactSessionInfo*>(
      &from));
}

void ContactSessionInfo::MergeFrom(const ContactSessionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ContactSessionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_latest_msg_data(from._internal_latest_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      session_id_ = from.session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      session_status_ = from.session_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      updated_time_ = from.updated_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      latest_msg_id_ = from.latest_msg_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      latest_msg_from_user_id_ = from.latest_msg_from_user_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      session_type_ = from.session_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      latest_msg_type_ = from.latest_msg_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContactSessionInfo::CopyFrom(const ContactSessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ContactSessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContactSessionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ContactSessionInfo::InternalSwap(ContactSessionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &latest_msg_data_, lhs_arena,
      &other->latest_msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContactSessionInfo, latest_msg_from_user_id_)
      + sizeof(ContactSessionInfo::latest_msg_from_user_id_)
      - PROTOBUF_FIELD_OFFSET(ContactSessionInfo, session_id_)>(
          reinterpret_cast<char*>(&session_id_),
          reinterpret_cast<char*>(&other->session_id_));
  swap(session_type_, other->session_type_);
  swap(latest_msg_type_, other->latest_msg_type_);
}

std::string ContactSessionInfo::GetTypeName() const {
  return "IM.BaseDefine.ContactSessionInfo";
}


// ===================================================================

class UserStat::_Internal {
 public:
  using HasBits = decltype(std::declval<UserStat>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UserStat::UserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserStat)
}
UserStat::UserStat(const UserStat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserStat)
}

inline void UserStat::SharedCtor() {
user_id_ = 0u;
status_ = 1;
}

UserStat::~UserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserStat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UserStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserStat::ArenaDtor(void* object) {
  UserStat* _this = reinterpret_cast< UserStat* >(object);
  (void)_this;
}
void UserStat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserStat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserStat::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    user_id_ = 0u;
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserStat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.UserStatType status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::UserStatType_IsValid(val))) {
            _internal_set_status(static_cast<::IM::BaseDefine::UserStatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.UserStatType status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserStat)
  return target;
}

size_t UserStat::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.UserStat)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_status()) {
    // required .IM.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t UserStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserStat)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required .IM.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserStat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UserStat*>(
      &from));
}

void UserStat::MergeFrom(const UserStat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserStat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserStat::CopyFrom(const UserStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserStat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UserStat::InternalSwap(UserStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_id_, other->user_id_);
  swap(status_, other->status_);
}

std::string UserStat::GetTypeName() const {
  return "IM.BaseDefine.UserStat";
}


// ===================================================================

class ServerUserStat::_Internal {
 public:
  using HasBits = decltype(std::declval<ServerUserStat>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

ServerUserStat::ServerUserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ServerUserStat)
}
ServerUserStat::ServerUserStat(const ServerUserStat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(client_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ServerUserStat)
}

inline void ServerUserStat::SharedCtor() {
user_id_ = 0u;
status_ = 1;
client_type_ = 1;
}

ServerUserStat::~ServerUserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ServerUserStat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ServerUserStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServerUserStat::ArenaDtor(void* object) {
  ServerUserStat* _this = reinterpret_cast< ServerUserStat* >(object);
  (void)_this;
}
void ServerUserStat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ServerUserStat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServerUserStat::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ServerUserStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    user_id_ = 0u;
    status_ = 1;
    client_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ServerUserStat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.UserStatType status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::UserStatType_IsValid(val))) {
            _internal_set_status(static_cast<::IM::BaseDefine::UserStatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.ClientType client_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::ClientType_IsValid(val))) {
            _internal_set_client_type(static_cast<::IM::BaseDefine::ClientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerUserStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ServerUserStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.UserStatType status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // required .IM.BaseDefine.ClientType client_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_client_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ServerUserStat)
  return target;
}

size_t ServerUserStat::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.ServerUserStat)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_status()) {
    // required .IM.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (_internal_has_client_type()) {
    // required .IM.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_client_type());
  }

  return total_size;
}
size_t ServerUserStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ServerUserStat)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required .IM.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

    // required .IM.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_client_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServerUserStat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ServerUserStat*>(
      &from));
}

void ServerUserStat::MergeFrom(const ServerUserStat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ServerUserStat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000004u) {
      client_type_ = from.client_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServerUserStat::CopyFrom(const ServerUserStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ServerUserStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerUserStat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ServerUserStat::InternalSwap(ServerUserStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_id_, other->user_id_);
  swap(status_, other->status_);
  swap(client_type_, other->client_type_);
}

std::string ServerUserStat::GetTypeName() const {
  return "IM.BaseDefine.ServerUserStat";
}


// ===================================================================

class UnreadInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UnreadInfo>()._has_bits_);
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_unread_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_latest_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_latest_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latest_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_latest_msg_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

UnreadInfo::UnreadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UnreadInfo)
}
UnreadInfo::UnreadInfo(const UnreadInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  latest_msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    latest_msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_latest_msg_data()) {
    latest_msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_latest_msg_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&session_id_, &from.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_msg_type_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UnreadInfo)
}

inline void UnreadInfo::SharedCtor() {
latest_msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  latest_msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&session_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_msg_from_user_id_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_from_user_id_));
session_type_ = 1;
latest_msg_type_ = 1;
}

UnreadInfo::~UnreadInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UnreadInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UnreadInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  latest_msg_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UnreadInfo::ArenaDtor(void* object) {
  UnreadInfo* _this = reinterpret_cast< UnreadInfo* >(object);
  (void)_this;
}
void UnreadInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UnreadInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UnreadInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UnreadInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    latest_msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_msg_from_user_id_) -
        reinterpret_cast<char*>(&session_id_)) + sizeof(latest_msg_from_user_id_));
    session_type_ = 1;
    latest_msg_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UnreadInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_session_id(&has_bits);
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 unread_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_unread_cnt(&has_bits);
          unread_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_latest_msg_id(&has_bits);
          latest_msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes latest_msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_latest_msg_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.MsgType latest_msg_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_latest_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_from_user_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_latest_msg_from_user_id(&has_bits);
          latest_msg_from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnreadInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UnreadInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 session_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // required uint32 unread_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_unread_cnt(), target);
  }

  // required uint32 latest_msg_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_latest_msg_id(), target);
  }

  // required bytes latest_msg_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_latest_msg_data(), target);
  }

  // required .IM.BaseDefine.MsgType latest_msg_type = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_latest_msg_type(), target);
  }

  // required uint32 latest_msg_from_user_id = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_latest_msg_from_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UnreadInfo)
  return target;
}

size_t UnreadInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.UnreadInfo)
  size_t total_size = 0;

  if (_internal_has_latest_msg_data()) {
    // required bytes latest_msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_unread_cnt()) {
    // required uint32 unread_cnt = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());
  }

  if (_internal_has_latest_msg_id()) {
    // required uint32 latest_msg_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());
  }

  if (_internal_has_latest_msg_from_user_id()) {
    // required uint32 latest_msg_from_user_id = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());
  }

  if (_internal_has_session_type()) {
    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  if (_internal_has_latest_msg_type()) {
    // required .IM.BaseDefine.MsgType latest_msg_type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_latest_msg_type());
  }

  return total_size;
}
size_t UnreadInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UnreadInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required bytes latest_msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());

    // required uint32 session_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required uint32 unread_cnt = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());

    // required uint32 latest_msg_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());

    // required uint32 latest_msg_from_user_id = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());

    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());

    // required .IM.BaseDefine.MsgType latest_msg_type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_latest_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnreadInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UnreadInfo*>(
      &from));
}

void UnreadInfo::MergeFrom(const UnreadInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UnreadInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_latest_msg_data(from._internal_latest_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      session_id_ = from.session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      unread_cnt_ = from.unread_cnt_;
    }
    if (cached_has_bits & 0x00000008u) {
      latest_msg_id_ = from.latest_msg_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      latest_msg_from_user_id_ = from.latest_msg_from_user_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      session_type_ = from.session_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      latest_msg_type_ = from.latest_msg_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UnreadInfo::CopyFrom(const UnreadInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UnreadInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnreadInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UnreadInfo::InternalSwap(UnreadInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &latest_msg_data_, lhs_arena,
      &other->latest_msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnreadInfo, latest_msg_from_user_id_)
      + sizeof(UnreadInfo::latest_msg_from_user_id_)
      - PROTOBUF_FIELD_OFFSET(UnreadInfo, session_id_)>(
          reinterpret_cast<char*>(&session_id_),
          reinterpret_cast<char*>(&other->session_id_));
  swap(session_type_, other->session_type_);
  swap(latest_msg_type_, other->latest_msg_type_);
}

std::string UnreadInfo::GetTypeName() const {
  return "IM.BaseDefine.UnreadInfo";
}


// ===================================================================

class MsgInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgInfo>()._has_bits_);
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_create_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

MsgInfo::MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.MsgInfo)
}
MsgInfo::MsgInfo(const MsgInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_msg_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&msg_id_, &from.msg_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&msg_type_) -
    reinterpret_cast<char*>(&msg_id_)) + sizeof(msg_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.MsgInfo)
}

inline void MsgInfo::SharedCtor() {
msg_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  msg_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&msg_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&create_time_) -
    reinterpret_cast<char*>(&msg_id_)) + sizeof(create_time_));
msg_type_ = 1;
}

MsgInfo::~MsgInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.MsgInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MsgInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  msg_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MsgInfo::ArenaDtor(void* object) {
  MsgInfo* _this = reinterpret_cast< MsgInfo* >(object);
  (void)_this;
}
void MsgInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MsgInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MsgInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.MsgInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&msg_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&create_time_) -
        reinterpret_cast<char*>(&msg_id_)) + sizeof(create_time_));
    msg_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 msg_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_id(&has_bits);
          msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 from_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_from_session_id(&has_bits);
          from_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 create_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_create_time(&has_bits);
          create_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.MsgType msg_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.MsgInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 msg_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_id(), target);
  }

  // required uint32 from_session_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_from_session_id(), target);
  }

  // required uint32 create_time = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_create_time(), target);
  }

  // required .IM.BaseDefine.MsgType msg_type = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_msg_type(), target);
  }

  // required bytes msg_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_msg_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.MsgInfo)
  return target;
}

size_t MsgInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.MsgInfo)
  size_t total_size = 0;

  if (_internal_has_msg_data()) {
    // required bytes msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg_data());
  }

  if (_internal_has_msg_id()) {
    // required uint32 msg_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  if (_internal_has_from_session_id()) {
    // required uint32 from_session_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_from_session_id());
  }

  if (_internal_has_create_time()) {
    // required uint32 create_time = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_create_time());
  }

  if (_internal_has_msg_type()) {
    // required .IM.BaseDefine.MsgType msg_type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_msg_type());
  }

  return total_size;
}
size_t MsgInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.MsgInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required bytes msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg_data());

    // required uint32 msg_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());

    // required uint32 from_session_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_from_session_id());

    // required uint32 create_time = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_create_time());

    // required .IM.BaseDefine.MsgType msg_type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MsgInfo*>(
      &from));
}

void MsgInfo::MergeFrom(const MsgInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.MsgInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      msg_id_ = from.msg_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      from_session_id_ = from.from_session_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      create_time_ = from.create_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      msg_type_ = from.msg_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgInfo::CopyFrom(const MsgInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.MsgInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void MsgInfo::InternalSwap(MsgInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &msg_data_, lhs_arena,
      &other->msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgInfo, create_time_)
      + sizeof(MsgInfo::create_time_)
      - PROTOBUF_FIELD_OFFSET(MsgInfo, msg_id_)>(
          reinterpret_cast<char*>(&msg_id_),
          reinterpret_cast<char*>(&other->msg_id_));
  swap(msg_type_, other->msg_type_);
}

std::string MsgInfo::GetTypeName() const {
  return "IM.BaseDefine.MsgInfo";
}


// ===================================================================

class GroupVersionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupVersionInfo>()._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GroupVersionInfo::GroupVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.GroupVersionInfo)
}
GroupVersionInfo::GroupVersionInfo(const GroupVersionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&group_id_, &from.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&group_id_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupVersionInfo)
}

inline void GroupVersionInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&group_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&group_id_)) + sizeof(version_));
}

GroupVersionInfo::~GroupVersionInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupVersionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GroupVersionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GroupVersionInfo::ArenaDtor(void* object) {
  GroupVersionInfo* _this = reinterpret_cast< GroupVersionInfo* >(object);
  (void)_this;
}
void GroupVersionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GroupVersionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GroupVersionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.GroupVersionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&group_id_)) + sizeof(version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupVersionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupVersionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.GroupVersionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.GroupVersionInfo)
  return target;
}

size_t GroupVersionInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.GroupVersionInfo)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_version()) {
    // required uint32 version = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  return total_size;
}
size_t GroupVersionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.GroupVersionInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 group_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 version = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupVersionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GroupVersionInfo*>(
      &from));
}

void GroupVersionInfo::MergeFrom(const GroupVersionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.GroupVersionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      group_id_ = from.group_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupVersionInfo::CopyFrom(const GroupVersionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.GroupVersionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupVersionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GroupVersionInfo::InternalSwap(GroupVersionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupVersionInfo, version_)
      + sizeof(GroupVersionInfo::version_)
      - PROTOBUF_FIELD_OFFSET(GroupVersionInfo, group_id_)>(
          reinterpret_cast<char*>(&group_id_),
          reinterpret_cast<char*>(&other->group_id_));
}

std::string GroupVersionInfo::GetTypeName() const {
  return "IM.BaseDefine.GroupVersionInfo";
}


// ===================================================================

class GroupInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupInfo>()._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_group_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_avatar(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_creator_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_group_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shield_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

GroupInfo::GroupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  group_member_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.GroupInfo)
}
GroupInfo::GroupInfo(const GroupInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      group_member_list_(from.group_member_list_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  group_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    group_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_name()) {
    group_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_group_name(), 
      GetArenaForAllocation());
  }
  group_avatar_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    group_avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_avatar()) {
    group_avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_group_avatar(), 
      GetArenaForAllocation());
  }
  ::memcpy(&group_id_, &from.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_type_) -
    reinterpret_cast<char*>(&group_id_)) + sizeof(group_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupInfo)
}

inline void GroupInfo::SharedCtor() {
group_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  group_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
group_avatar_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  group_avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&group_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&group_id_)) + sizeof(shield_status_));
group_type_ = 1;
}

GroupInfo::~GroupInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GroupInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  group_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  group_avatar_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GroupInfo::ArenaDtor(void* object) {
  GroupInfo* _this = reinterpret_cast< GroupInfo* >(object);
  (void)_this;
}
void GroupInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GroupInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GroupInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.GroupInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  group_member_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      group_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      group_avatar_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shield_status_) -
        reinterpret_cast<char*>(&group_id_)) + sizeof(shield_status_));
    group_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_group_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group_avatar = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_group_avatar();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_creator_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_group_creator_id(&has_bits);
          group_creator_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.GroupType group_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::GroupType_IsValid(val))) {
            _internal_set_group_type(static_cast<::IM::BaseDefine::GroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 shield_status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_shield_status(&has_bits);
          shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 group_member_list = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_group_member_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_group_member_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.GroupInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 version = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  // required string group_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_group_name(), target);
  }

  // required string group_avatar = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_group_avatar(), target);
  }

  // required uint32 group_creator_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_group_creator_id(), target);
  }

  // required .IM.BaseDefine.GroupType group_type = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_group_type(), target);
  }

  // required uint32 shield_status = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_shield_status(), target);
  }

  // repeated uint32 group_member_list = 8;
  for (int i = 0, n = this->_internal_group_member_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_group_member_list(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.GroupInfo)
  return target;
}

size_t GroupInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.GroupInfo)
  size_t total_size = 0;

  if (_internal_has_group_name()) {
    // required string group_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_name());
  }

  if (_internal_has_group_avatar()) {
    // required string group_avatar = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_avatar());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_version()) {
    // required uint32 version = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  if (_internal_has_group_creator_id()) {
    // required uint32 group_creator_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_creator_id());
  }

  if (_internal_has_shield_status()) {
    // required uint32 shield_status = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  if (_internal_has_group_type()) {
    // required .IM.BaseDefine.GroupType group_type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_group_type());
  }

  return total_size;
}
size_t GroupInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.GroupInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string group_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_name());

    // required string group_avatar = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_avatar());

    // required uint32 group_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 version = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

    // required uint32 group_creator_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_creator_id());

    // required uint32 shield_status = 7;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());

    // required .IM.BaseDefine.GroupType group_type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_group_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 group_member_list = 8;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->group_member_list_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_group_member_list_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GroupInfo*>(
      &from));
}

void GroupInfo::MergeFrom(const GroupInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.GroupInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  group_member_list_.MergeFrom(from.group_member_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_group_name(from._internal_group_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_group_avatar(from._internal_group_avatar());
    }
    if (cached_has_bits & 0x00000004u) {
      group_id_ = from.group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000010u) {
      group_creator_id_ = from.group_creator_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      shield_status_ = from.shield_status_;
    }
    if (cached_has_bits & 0x00000040u) {
      group_type_ = from.group_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupInfo::CopyFrom(const GroupInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.GroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GroupInfo::InternalSwap(GroupInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  group_member_list_.InternalSwap(&other->group_member_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &group_name_, lhs_arena,
      &other->group_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &group_avatar_, lhs_arena,
      &other->group_avatar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupInfo, shield_status_)
      + sizeof(GroupInfo::shield_status_)
      - PROTOBUF_FIELD_OFFSET(GroupInfo, group_id_)>(
          reinterpret_cast<char*>(&group_id_),
          reinterpret_cast<char*>(&other->group_id_));
  swap(group_type_, other->group_type_);
}

std::string GroupInfo::GetTypeName() const {
  return "IM.BaseDefine.GroupInfo";
}


// ===================================================================

class UserTokenInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserTokenInfo>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_push_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_push_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

UserTokenInfo::UserTokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserTokenInfo)
}
UserTokenInfo::UserTokenInfo(const UserTokenInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&user_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(user_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserTokenInfo)
}

inline void UserTokenInfo::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&push_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(push_type_));
user_type_ = 1;
}

UserTokenInfo::~UserTokenInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserTokenInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void UserTokenInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UserTokenInfo::ArenaDtor(void* object) {
  UserTokenInfo* _this = reinterpret_cast< UserTokenInfo* >(object);
  (void)_this;
}
void UserTokenInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserTokenInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserTokenInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserTokenInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&push_type_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(push_type_));
    user_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserTokenInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.ClientType user_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::ClientType_IsValid(val))) {
            _internal_set_user_type(static_cast<::IM::BaseDefine::ClientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 push_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_push_count(&has_bits);
          push_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 push_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_push_type(&has_bits);
          push_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserTokenInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserTokenInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.ClientType user_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_user_type(), target);
  }

  // required string token = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_token(), target);
  }

  // required uint32 push_count = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_push_count(), target);
  }

  // required uint32 push_type = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_push_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserTokenInfo)
  return target;
}

size_t UserTokenInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.UserTokenInfo)
  size_t total_size = 0;

  if (_internal_has_token()) {
    // required string token = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());
  }

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_push_count()) {
    // required uint32 push_count = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_push_count());
  }

  if (_internal_has_push_type()) {
    // required uint32 push_type = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_push_type());
  }

  if (_internal_has_user_type()) {
    // required .IM.BaseDefine.ClientType user_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_user_type());
  }

  return total_size;
}
size_t UserTokenInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserTokenInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string token = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());

    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 push_count = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_push_count());

    // required uint32 push_type = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_push_type());

    // required .IM.BaseDefine.ClientType user_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_user_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserTokenInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UserTokenInfo*>(
      &from));
}

void UserTokenInfo::MergeFrom(const UserTokenInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserTokenInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      push_count_ = from.push_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      push_type_ = from.push_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      user_type_ = from.user_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserTokenInfo::CopyFrom(const UserTokenInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserTokenInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTokenInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UserTokenInfo::InternalSwap(UserTokenInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserTokenInfo, push_type_)
      + sizeof(UserTokenInfo::push_type_)
      - PROTOBUF_FIELD_OFFSET(UserTokenInfo, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
  swap(user_type_, other->user_type_);
}

std::string UserTokenInfo::GetTypeName() const {
  return "IM.BaseDefine.UserTokenInfo";
}


// ===================================================================

class PushResult::_Internal {
 public:
  using HasBits = decltype(std::declval<PushResult>()._has_bits_);
  static void set_has_user_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_result_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PushResult::PushResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.PushResult)
}
PushResult::PushResult(const PushResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  user_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_token()) {
    user_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_token(), 
      GetArenaForAllocation());
  }
  result_code_ = from.result_code_;
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.PushResult)
}

inline void PushResult::SharedCtor() {
user_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
result_code_ = 0u;
}

PushResult::~PushResult() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.PushResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PushResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PushResult::ArenaDtor(void* object) {
  PushResult* _this = reinterpret_cast< PushResult* >(object);
  (void)_this;
}
void PushResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PushResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PushResult::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.PushResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    user_token_.ClearNonDefaultToEmpty();
  }
  result_code_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PushResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string user_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result_code(&has_bits);
          result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.PushResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string user_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_token(), target);
  }

  // required uint32 result_code = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.PushResult)
  return target;
}

size_t PushResult::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.PushResult)
  size_t total_size = 0;

  if (_internal_has_user_token()) {
    // required string user_token = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_token());
  }

  if (_internal_has_result_code()) {
    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  return total_size;
}
size_t PushResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.PushResult)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string user_token = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_token());

    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PushResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PushResult*>(
      &from));
}

void PushResult::MergeFrom(const PushResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.PushResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_token(from._internal_user_token());
    }
    if (cached_has_bits & 0x00000002u) {
      result_code_ = from.result_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PushResult::CopyFrom(const PushResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.PushResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushResult::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PushResult::InternalSwap(PushResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_token_, lhs_arena,
      &other->user_token_, rhs_arena
  );
  swap(result_code_, other->result_code_);
}

std::string PushResult::GetTypeName() const {
  return "IM.BaseDefine.PushResult";
}


// ===================================================================

class ShieldStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ShieldStatus>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_shield_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

ShieldStatus::ShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ShieldStatus)
}
ShieldStatus::ShieldStatus(const ShieldStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ShieldStatus)
}

inline void ShieldStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
}

ShieldStatus::~ShieldStatus() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ShieldStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ShieldStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShieldStatus::ArenaDtor(void* object) {
  ShieldStatus* _this = reinterpret_cast< ShieldStatus* >(object);
  (void)_this;
}
void ShieldStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ShieldStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShieldStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ShieldStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shield_status_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShieldStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 shield_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_shield_status(&has_bits);
          shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShieldStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ShieldStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // required uint32 shield_status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_shield_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ShieldStatus)
  return target;
}

size_t ShieldStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.ShieldStatus)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_shield_status()) {
    // required uint32 shield_status = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  return total_size;
}
size_t ShieldStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ShieldStatus)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 group_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 shield_status = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShieldStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ShieldStatus*>(
      &from));
}

void ShieldStatus::MergeFrom(const ShieldStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ShieldStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_id_ = from.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      shield_status_ = from.shield_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShieldStatus::CopyFrom(const ShieldStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ShieldStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShieldStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ShieldStatus::InternalSwap(ShieldStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShieldStatus, shield_status_)
      + sizeof(ShieldStatus::shield_status_)
      - PROTOBUF_FIELD_OFFSET(ShieldStatus, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string ShieldStatus::GetTypeName() const {
  return "IM.BaseDefine.ShieldStatus";
}


// ===================================================================

class OfflineFileInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<OfflineFileInfo>()._has_bits_);
  static void set_has_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_task_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_file_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

OfflineFileInfo::OfflineFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.OfflineFileInfo)
}
OfflineFileInfo::OfflineFileInfo(const OfflineFileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  task_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    task_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_task_id()) {
    task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_task_id(), 
      GetArenaForAllocation());
  }
  file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_name()) {
    file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&from_user_id_, &from.from_user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&file_size_) -
    reinterpret_cast<char*>(&from_user_id_)) + sizeof(file_size_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.OfflineFileInfo)
}

inline void OfflineFileInfo::SharedCtor() {
task_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  task_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&from_user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&file_size_) -
    reinterpret_cast<char*>(&from_user_id_)) + sizeof(file_size_));
}

OfflineFileInfo::~OfflineFileInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.OfflineFileInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void OfflineFileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  task_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void OfflineFileInfo::ArenaDtor(void* object) {
  OfflineFileInfo* _this = reinterpret_cast< OfflineFileInfo* >(object);
  (void)_this;
}
void OfflineFileInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OfflineFileInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OfflineFileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.OfflineFileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      task_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      file_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&from_user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&file_size_) -
        reinterpret_cast<char*>(&from_user_id_)) + sizeof(file_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OfflineFileInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 from_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_from_user_id(&has_bits);
          from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string task_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_task_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string file_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_file_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 file_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_file_size(&has_bits);
          file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfflineFileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.OfflineFileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 from_user_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_from_user_id(), target);
  }

  // required string task_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_task_id(), target);
  }

  // required string file_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_file_name(), target);
  }

  // required uint32 file_size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_file_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.OfflineFileInfo)
  return target;
}

size_t OfflineFileInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.OfflineFileInfo)
  size_t total_size = 0;

  if (_internal_has_task_id()) {
    // required string task_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_task_id());
  }

  if (_internal_has_file_name()) {
    // required string file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_name());
  }

  if (_internal_has_from_user_id()) {
    // required uint32 from_user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_from_user_id());
  }

  if (_internal_has_file_size()) {
    // required uint32 file_size = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_file_size());
  }

  return total_size;
}
size_t OfflineFileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.OfflineFileInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string task_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_task_id());

    // required string file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_name());

    // required uint32 from_user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_from_user_id());

    // required uint32 file_size = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_file_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OfflineFileInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const OfflineFileInfo*>(
      &from));
}

void OfflineFileInfo::MergeFrom(const OfflineFileInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.OfflineFileInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_task_id(from._internal_task_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_file_name(from._internal_file_name());
    }
    if (cached_has_bits & 0x00000004u) {
      from_user_id_ = from.from_user_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      file_size_ = from.file_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OfflineFileInfo::CopyFrom(const OfflineFileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.OfflineFileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineFileInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void OfflineFileInfo::InternalSwap(OfflineFileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &task_id_, lhs_arena,
      &other->task_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_name_, lhs_arena,
      &other->file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfflineFileInfo, file_size_)
      + sizeof(OfflineFileInfo::file_size_)
      - PROTOBUF_FIELD_OFFSET(OfflineFileInfo, from_user_id_)>(
          reinterpret_cast<char*>(&from_user_id_),
          reinterpret_cast<char*>(&other->from_user_id_));
}

std::string OfflineFileInfo::GetTypeName() const {
  return "IM.BaseDefine.OfflineFileInfo";
}


// ===================================================================

class DepartInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DepartInfo>()._has_bits_);
  static void set_has_dept_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dept_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_dept_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dept_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

DepartInfo::DepartInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.DepartInfo)
}
DepartInfo::DepartInfo(const DepartInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  dept_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    dept_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dept_name()) {
    dept_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_dept_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&dept_id_, &from.dept_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&dept_status_) -
    reinterpret_cast<char*>(&dept_id_)) + sizeof(dept_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.DepartInfo)
}

inline void DepartInfo::SharedCtor() {
dept_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  dept_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dept_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dept_status_) -
    reinterpret_cast<char*>(&dept_id_)) + sizeof(dept_status_));
}

DepartInfo::~DepartInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.DepartInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void DepartInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  dept_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DepartInfo::ArenaDtor(void* object) {
  DepartInfo* _this = reinterpret_cast< DepartInfo* >(object);
  (void)_this;
}
void DepartInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DepartInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DepartInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.DepartInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    dept_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&dept_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dept_status_) -
        reinterpret_cast<char*>(&dept_id_)) + sizeof(dept_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DepartInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 dept_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dept_id(&has_bits);
          dept_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_priority(&has_bits);
          priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string dept_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_dept_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 parent_dept_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_parent_dept_id(&has_bits);
          parent_dept_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::DepartmentStatusType_IsValid(val))) {
            _internal_set_dept_status(static_cast<::IM::BaseDefine::DepartmentStatusType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DepartInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.DepartInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 dept_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dept_id(), target);
  }

  // required uint32 priority = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_priority(), target);
  }

  // required string dept_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_dept_name(), target);
  }

  // required uint32 parent_dept_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_parent_dept_id(), target);
  }

  // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_dept_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.DepartInfo)
  return target;
}

size_t DepartInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.DepartInfo)
  size_t total_size = 0;

  if (_internal_has_dept_name()) {
    // required string dept_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dept_name());
  }

  if (_internal_has_dept_id()) {
    // required uint32 dept_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_dept_id());
  }

  if (_internal_has_priority()) {
    // required uint32 priority = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());
  }

  if (_internal_has_parent_dept_id()) {
    // required uint32 parent_dept_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_dept_id());
  }

  if (_internal_has_dept_status()) {
    // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dept_status());
  }

  return total_size;
}
size_t DepartInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.DepartInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string dept_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dept_name());

    // required uint32 dept_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_dept_id());

    // required uint32 priority = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());

    // required uint32 parent_dept_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_dept_id());

    // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dept_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DepartInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DepartInfo*>(
      &from));
}

void DepartInfo::MergeFrom(const DepartInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.DepartInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_dept_name(from._internal_dept_name());
    }
    if (cached_has_bits & 0x00000002u) {
      dept_id_ = from.dept_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      priority_ = from.priority_;
    }
    if (cached_has_bits & 0x00000008u) {
      parent_dept_id_ = from.parent_dept_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      dept_status_ = from.dept_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DepartInfo::CopyFrom(const DepartInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.DepartInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DepartInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DepartInfo::InternalSwap(DepartInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &dept_name_, lhs_arena,
      &other->dept_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DepartInfo, dept_status_)
      + sizeof(DepartInfo::dept_status_)
      - PROTOBUF_FIELD_OFFSET(DepartInfo, dept_id_)>(
          reinterpret_cast<char*>(&dept_id_),
          reinterpret_cast<char*>(&other->dept_id_));
}

std::string DepartInfo::GetTypeName() const {
  return "IM.BaseDefine.DepartInfo";
}


// ===================================================================

class PushShieldStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PushShieldStatus>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shield_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PushShieldStatus::PushShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.PushShieldStatus)
}
PushShieldStatus::PushShieldStatus(const PushShieldStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.PushShieldStatus)
}

inline void PushShieldStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&shield_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
}

PushShieldStatus::~PushShieldStatus() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.PushShieldStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void PushShieldStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PushShieldStatus::ArenaDtor(void* object) {
  PushShieldStatus* _this = reinterpret_cast< PushShieldStatus* >(object);
  (void)_this;
}
void PushShieldStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PushShieldStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PushShieldStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.PushShieldStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shield_status_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(shield_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PushShieldStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 shield_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_shield_status(&has_bits);
          shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushShieldStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.PushShieldStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 shield_status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_shield_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.PushShieldStatus)
  return target;
}

size_t PushShieldStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.BaseDefine.PushShieldStatus)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_shield_status()) {
    // required uint32 shield_status = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  return total_size;
}
size_t PushShieldStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.PushShieldStatus)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 shield_status = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PushShieldStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PushShieldStatus*>(
      &from));
}

void PushShieldStatus::MergeFrom(const PushShieldStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.PushShieldStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      shield_status_ = from.shield_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PushShieldStatus::CopyFrom(const PushShieldStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.PushShieldStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushShieldStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PushShieldStatus::InternalSwap(PushShieldStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PushShieldStatus, shield_status_)
      + sizeof(PushShieldStatus::shield_status_)
      - PROTOBUF_FIELD_OFFSET(PushShieldStatus, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string PushShieldStatus::GetTypeName() const {
  return "IM.BaseDefine.PushShieldStatus";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace BaseDefine
}  // namespace IM
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::IpAddr* Arena::CreateMaybeMessage< ::IM::BaseDefine::IpAddr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::IpAddr >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::UserInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ContactSessionInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::ContactSessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ContactSessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserStat* Arena::CreateMaybeMessage< ::IM::BaseDefine::UserStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserStat >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ServerUserStat* Arena::CreateMaybeMessage< ::IM::BaseDefine::ServerUserStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ServerUserStat >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UnreadInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::UnreadInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UnreadInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::MsgInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::MsgInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::MsgInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::GroupVersionInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::GroupVersionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::GroupVersionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::GroupInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::GroupInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::GroupInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserTokenInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::UserTokenInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserTokenInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::PushResult* Arena::CreateMaybeMessage< ::IM::BaseDefine::PushResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::PushResult >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ShieldStatus* Arena::CreateMaybeMessage< ::IM::BaseDefine::ShieldStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ShieldStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::OfflineFileInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::OfflineFileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::OfflineFileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::DepartInfo* Arena::CreateMaybeMessage< ::IM::BaseDefine::DepartInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::DepartInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::PushShieldStatus* Arena::CreateMaybeMessage< ::IM::BaseDefine::PushShieldStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::PushShieldStatus >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
