// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Buddy.proto

#include "IM.Buddy.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace IM {
namespace Buddy {
constexpr IMRecentContactSessionReq::IMRecentContactSessionReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , latest_update_time_(0u){}
struct IMRecentContactSessionReqDefaultTypeInternal {
  constexpr IMRecentContactSessionReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMRecentContactSessionReqDefaultTypeInternal() {}
  union {
    IMRecentContactSessionReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMRecentContactSessionReqDefaultTypeInternal _IMRecentContactSessionReq_default_instance_;
constexpr IMRecentContactSessionRsp::IMRecentContactSessionRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : contact_session_list_()
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u){}
struct IMRecentContactSessionRspDefaultTypeInternal {
  constexpr IMRecentContactSessionRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMRecentContactSessionRspDefaultTypeInternal() {}
  union {
    IMRecentContactSessionRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMRecentContactSessionRspDefaultTypeInternal _IMRecentContactSessionRsp_default_instance_;
constexpr IMUserStatNotify::IMUserStatNotify(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_stat_(nullptr){}
struct IMUserStatNotifyDefaultTypeInternal {
  constexpr IMUserStatNotifyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMUserStatNotifyDefaultTypeInternal() {}
  union {
    IMUserStatNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMUserStatNotifyDefaultTypeInternal _IMUserStatNotify_default_instance_;
constexpr IMUsersInfoReq::IMUsersInfoReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_list_()
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u){}
struct IMUsersInfoReqDefaultTypeInternal {
  constexpr IMUsersInfoReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMUsersInfoReqDefaultTypeInternal() {}
  union {
    IMUsersInfoReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMUsersInfoReqDefaultTypeInternal _IMUsersInfoReq_default_instance_;
constexpr IMUsersInfoRsp::IMUsersInfoRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_info_list_()
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u){}
struct IMUsersInfoRspDefaultTypeInternal {
  constexpr IMUsersInfoRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMUsersInfoRspDefaultTypeInternal() {}
  union {
    IMUsersInfoRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMUsersInfoRspDefaultTypeInternal _IMUsersInfoRsp_default_instance_;
constexpr IMRemoveSessionReq::IMRemoveSessionReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , session_id_(0u)
  , session_type_(1)
{}
struct IMRemoveSessionReqDefaultTypeInternal {
  constexpr IMRemoveSessionReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMRemoveSessionReqDefaultTypeInternal() {}
  union {
    IMRemoveSessionReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMRemoveSessionReqDefaultTypeInternal _IMRemoveSessionReq_default_instance_;
constexpr IMRemoveSessionRsp::IMRemoveSessionRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , result_code_(0u)
  , session_id_(0u)
  , session_type_(1)
{}
struct IMRemoveSessionRspDefaultTypeInternal {
  constexpr IMRemoveSessionRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMRemoveSessionRspDefaultTypeInternal() {}
  union {
    IMRemoveSessionRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMRemoveSessionRspDefaultTypeInternal _IMRemoveSessionRsp_default_instance_;
constexpr IMAllUserReq::IMAllUserReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , latest_update_time_(0u){}
struct IMAllUserReqDefaultTypeInternal {
  constexpr IMAllUserReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMAllUserReqDefaultTypeInternal() {}
  union {
    IMAllUserReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMAllUserReqDefaultTypeInternal _IMAllUserReq_default_instance_;
constexpr IMAllUserRsp::IMAllUserRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_list_()
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , latest_update_time_(0u){}
struct IMAllUserRspDefaultTypeInternal {
  constexpr IMAllUserRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMAllUserRspDefaultTypeInternal() {}
  union {
    IMAllUserRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMAllUserRspDefaultTypeInternal _IMAllUserRsp_default_instance_;
constexpr IMUsersStatReq::IMUsersStatReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_list_()
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u){}
struct IMUsersStatReqDefaultTypeInternal {
  constexpr IMUsersStatReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMUsersStatReqDefaultTypeInternal() {}
  union {
    IMUsersStatReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMUsersStatReqDefaultTypeInternal _IMUsersStatReq_default_instance_;
constexpr IMUsersStatRsp::IMUsersStatRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_stat_list_()
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u){}
struct IMUsersStatRspDefaultTypeInternal {
  constexpr IMUsersStatRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMUsersStatRspDefaultTypeInternal() {}
  union {
    IMUsersStatRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMUsersStatRspDefaultTypeInternal _IMUsersStatRsp_default_instance_;
constexpr IMChangeAvatarReq::IMChangeAvatarReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : avatar_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u){}
struct IMChangeAvatarReqDefaultTypeInternal {
  constexpr IMChangeAvatarReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMChangeAvatarReqDefaultTypeInternal() {}
  union {
    IMChangeAvatarReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMChangeAvatarReqDefaultTypeInternal _IMChangeAvatarReq_default_instance_;
constexpr IMChangeAvatarRsp::IMChangeAvatarRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , result_code_(0u){}
struct IMChangeAvatarRspDefaultTypeInternal {
  constexpr IMChangeAvatarRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMChangeAvatarRspDefaultTypeInternal() {}
  union {
    IMChangeAvatarRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMChangeAvatarRspDefaultTypeInternal _IMChangeAvatarRsp_default_instance_;
constexpr IMPCLoginStatusNotify::IMPCLoginStatusNotify(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , login_stat_(1)
{}
struct IMPCLoginStatusNotifyDefaultTypeInternal {
  constexpr IMPCLoginStatusNotifyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMPCLoginStatusNotifyDefaultTypeInternal() {}
  union {
    IMPCLoginStatusNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMPCLoginStatusNotifyDefaultTypeInternal _IMPCLoginStatusNotify_default_instance_;
constexpr IMRemoveSessionNotify::IMRemoveSessionNotify(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0u)
  , session_id_(0u)
  , session_type_(1)
{}
struct IMRemoveSessionNotifyDefaultTypeInternal {
  constexpr IMRemoveSessionNotifyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMRemoveSessionNotifyDefaultTypeInternal() {}
  union {
    IMRemoveSessionNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMRemoveSessionNotifyDefaultTypeInternal _IMRemoveSessionNotify_default_instance_;
constexpr IMDepartmentReq::IMDepartmentReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , latest_update_time_(0u){}
struct IMDepartmentReqDefaultTypeInternal {
  constexpr IMDepartmentReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMDepartmentReqDefaultTypeInternal() {}
  union {
    IMDepartmentReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMDepartmentReqDefaultTypeInternal _IMDepartmentReq_default_instance_;
constexpr IMDepartmentRsp::IMDepartmentRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dept_list_()
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , latest_update_time_(0u){}
struct IMDepartmentRspDefaultTypeInternal {
  constexpr IMDepartmentRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMDepartmentRspDefaultTypeInternal() {}
  union {
    IMDepartmentRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMDepartmentRspDefaultTypeInternal _IMDepartmentRsp_default_instance_;
constexpr IMAvatarChangedNotify::IMAvatarChangedNotify(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : avatar_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , changed_user_id_(0u){}
struct IMAvatarChangedNotifyDefaultTypeInternal {
  constexpr IMAvatarChangedNotifyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMAvatarChangedNotifyDefaultTypeInternal() {}
  union {
    IMAvatarChangedNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMAvatarChangedNotifyDefaultTypeInternal _IMAvatarChangedNotify_default_instance_;
constexpr IMChangeSignInfoReq::IMChangeSignInfoReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sign_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u){}
struct IMChangeSignInfoReqDefaultTypeInternal {
  constexpr IMChangeSignInfoReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMChangeSignInfoReqDefaultTypeInternal() {}
  union {
    IMChangeSignInfoReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMChangeSignInfoReqDefaultTypeInternal _IMChangeSignInfoReq_default_instance_;
constexpr IMChangeSignInfoRsp::IMChangeSignInfoRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sign_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , attach_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_id_(0u)
  , result_code_(0u){}
struct IMChangeSignInfoRspDefaultTypeInternal {
  constexpr IMChangeSignInfoRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMChangeSignInfoRspDefaultTypeInternal() {}
  union {
    IMChangeSignInfoRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMChangeSignInfoRspDefaultTypeInternal _IMChangeSignInfoRsp_default_instance_;
constexpr IMSignInfoChangedNotify::IMSignInfoChangedNotify(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sign_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , changed_user_id_(0u){}
struct IMSignInfoChangedNotifyDefaultTypeInternal {
  constexpr IMSignInfoChangedNotifyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IMSignInfoChangedNotifyDefaultTypeInternal() {}
  union {
    IMSignInfoChangedNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IMSignInfoChangedNotifyDefaultTypeInternal _IMSignInfoChangedNotify_default_instance_;
}  // namespace Buddy
}  // namespace IM
namespace IM {
namespace Buddy {

// ===================================================================

class IMRecentContactSessionReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRecentContactSessionReq>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_latest_update_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

IMRecentContactSessionReq::IMRecentContactSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRecentContactSessionReq)
}
IMRecentContactSessionReq::IMRecentContactSessionReq(const IMRecentContactSessionReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRecentContactSessionReq)
}

inline void IMRecentContactSessionReq::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
}

IMRecentContactSessionReq::~IMRecentContactSessionReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRecentContactSessionReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMRecentContactSessionReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMRecentContactSessionReq::ArenaDtor(void* object) {
  IMRecentContactSessionReq* _this = reinterpret_cast< IMRecentContactSessionReq* >(object);
  (void)_this;
}
void IMRecentContactSessionReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMRecentContactSessionReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMRecentContactSessionReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRecentContactSessionReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_update_time_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRecentContactSessionReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_latest_update_time(&has_bits);
          latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRecentContactSessionReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRecentContactSessionReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 latest_update_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRecentContactSessionReq)
  return target;
}

size_t IMRecentContactSessionReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMRecentContactSessionReq)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_latest_update_time()) {
    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  return total_size;
}
size_t IMRecentContactSessionReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRecentContactSessionReq)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRecentContactSessionReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMRecentContactSessionReq*>(
      &from));
}

void IMRecentContactSessionReq::MergeFrom(const IMRecentContactSessionReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRecentContactSessionReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      latest_update_time_ = from.latest_update_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRecentContactSessionReq::CopyFrom(const IMRecentContactSessionReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRecentContactSessionReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRecentContactSessionReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMRecentContactSessionReq::InternalSwap(IMRecentContactSessionReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMRecentContactSessionReq, latest_update_time_)
      + sizeof(IMRecentContactSessionReq::latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMRecentContactSessionReq, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string IMRecentContactSessionReq::GetTypeName() const {
  return "IM.Buddy.IMRecentContactSessionReq";
}


// ===================================================================

class IMRecentContactSessionRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRecentContactSessionRsp>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

void IMRecentContactSessionRsp::clear_contact_session_list() {
  contact_session_list_.Clear();
}
IMRecentContactSessionRsp::IMRecentContactSessionRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  contact_session_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRecentContactSessionRsp)
}
IMRecentContactSessionRsp::IMRecentContactSessionRsp(const IMRecentContactSessionRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      contact_session_list_(from.contact_session_list_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRecentContactSessionRsp)
}

inline void IMRecentContactSessionRsp::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_ = 0u;
}

IMRecentContactSessionRsp::~IMRecentContactSessionRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRecentContactSessionRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMRecentContactSessionRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMRecentContactSessionRsp::ArenaDtor(void* object) {
  IMRecentContactSessionRsp* _this = reinterpret_cast< IMRecentContactSessionRsp* >(object);
  (void)_this;
}
void IMRecentContactSessionRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMRecentContactSessionRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMRecentContactSessionRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRecentContactSessionRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  contact_session_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRecentContactSessionRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contact_session_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRecentContactSessionRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRecentContactSessionRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_contact_session_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_contact_session_list(i), target, stream);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRecentContactSessionRsp)
  return target;
}

size_t IMRecentContactSessionRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRecentContactSessionRsp)
  size_t total_size = 0;

  // required uint32 user_id = 1;
  if (_internal_has_user_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  total_size += 1UL * this->_internal_contact_session_list_size();
  for (const auto& msg : this->contact_session_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRecentContactSessionRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMRecentContactSessionRsp*>(
      &from));
}

void IMRecentContactSessionRsp::MergeFrom(const IMRecentContactSessionRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRecentContactSessionRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  contact_session_list_.MergeFrom(from.contact_session_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRecentContactSessionRsp::CopyFrom(const IMRecentContactSessionRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRecentContactSessionRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRecentContactSessionRsp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(contact_session_list_))
    return false;
  return true;
}

void IMRecentContactSessionRsp::InternalSwap(IMRecentContactSessionRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  contact_session_list_.InternalSwap(&other->contact_session_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  swap(user_id_, other->user_id_);
}

std::string IMRecentContactSessionRsp::GetTypeName() const {
  return "IM.Buddy.IMRecentContactSessionRsp";
}


// ===================================================================

class IMUserStatNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUserStatNotify>()._has_bits_);
  static const ::IM::BaseDefine::UserStat& user_stat(const IMUserStatNotify* msg);
  static void set_has_user_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::IM::BaseDefine::UserStat&
IMUserStatNotify::_Internal::user_stat(const IMUserStatNotify* msg) {
  return *msg->user_stat_;
}
void IMUserStatNotify::clear_user_stat() {
  if (user_stat_ != nullptr) user_stat_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
IMUserStatNotify::IMUserStatNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUserStatNotify)
}
IMUserStatNotify::IMUserStatNotify(const IMUserStatNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_user_stat()) {
    user_stat_ = new ::IM::BaseDefine::UserStat(*from.user_stat_);
  } else {
    user_stat_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUserStatNotify)
}

inline void IMUserStatNotify::SharedCtor() {
user_stat_ = nullptr;
}

IMUserStatNotify::~IMUserStatNotify() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUserStatNotify)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMUserStatNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete user_stat_;
}

void IMUserStatNotify::ArenaDtor(void* object) {
  IMUserStatNotify* _this = reinterpret_cast< IMUserStatNotify* >(object);
  (void)_this;
}
void IMUserStatNotify::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMUserStatNotify::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMUserStatNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUserStatNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(user_stat_ != nullptr);
    user_stat_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUserStatNotify::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .IM.BaseDefine.UserStat user_stat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_stat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUserStatNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUserStatNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .IM.BaseDefine.UserStat user_stat = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::user_stat(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUserStatNotify)
  return target;
}

size_t IMUserStatNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUserStatNotify)
  size_t total_size = 0;

  // required .IM.BaseDefine.UserStat user_stat = 1;
  if (_internal_has_user_stat()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_stat_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUserStatNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMUserStatNotify*>(
      &from));
}

void IMUserStatNotify::MergeFrom(const IMUserStatNotify& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUserStatNotify)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user_stat()) {
    _internal_mutable_user_stat()->::IM::BaseDefine::UserStat::MergeFrom(from._internal_user_stat());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUserStatNotify::CopyFrom(const IMUserStatNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUserStatNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserStatNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_user_stat()) {
    if (!user_stat_->IsInitialized()) return false;
  }
  return true;
}

void IMUserStatNotify::InternalSwap(IMUserStatNotify* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_stat_, other->user_stat_);
}

std::string IMUserStatNotify::GetTypeName() const {
  return "IM.Buddy.IMUserStatNotify";
}


// ===================================================================

class IMUsersInfoReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUsersInfoReq>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

IMUsersInfoReq::IMUsersInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  user_id_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUsersInfoReq)
}
IMUsersInfoReq::IMUsersInfoReq(const IMUsersInfoReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      user_id_list_(from.user_id_list_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUsersInfoReq)
}

inline void IMUsersInfoReq::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_ = 0u;
}

IMUsersInfoReq::~IMUsersInfoReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUsersInfoReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMUsersInfoReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMUsersInfoReq::ArenaDtor(void* object) {
  IMUsersInfoReq* _this = reinterpret_cast< IMUsersInfoReq* >(object);
  (void)_this;
}
void IMUsersInfoReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMUsersInfoReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMUsersInfoReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUsersInfoReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUsersInfoReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 user_id_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_user_id_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_user_id_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUsersInfoReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUsersInfoReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated uint32 user_id_list = 2;
  for (int i = 0, n = this->_internal_user_id_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_id_list(i), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUsersInfoReq)
  return target;
}

size_t IMUsersInfoReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUsersInfoReq)
  size_t total_size = 0;

  // required uint32 user_id = 1;
  if (_internal_has_user_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 user_id_list = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->user_id_list_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_user_id_list_size());
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUsersInfoReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMUsersInfoReq*>(
      &from));
}

void IMUsersInfoReq::MergeFrom(const IMUsersInfoReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUsersInfoReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  user_id_list_.MergeFrom(from.user_id_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUsersInfoReq::CopyFrom(const IMUsersInfoReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUsersInfoReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsersInfoReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMUsersInfoReq::InternalSwap(IMUsersInfoReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  user_id_list_.InternalSwap(&other->user_id_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  swap(user_id_, other->user_id_);
}

std::string IMUsersInfoReq::GetTypeName() const {
  return "IM.Buddy.IMUsersInfoReq";
}


// ===================================================================

class IMUsersInfoRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUsersInfoRsp>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

void IMUsersInfoRsp::clear_user_info_list() {
  user_info_list_.Clear();
}
IMUsersInfoRsp::IMUsersInfoRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  user_info_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUsersInfoRsp)
}
IMUsersInfoRsp::IMUsersInfoRsp(const IMUsersInfoRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      user_info_list_(from.user_info_list_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUsersInfoRsp)
}

inline void IMUsersInfoRsp::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_ = 0u;
}

IMUsersInfoRsp::~IMUsersInfoRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUsersInfoRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMUsersInfoRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMUsersInfoRsp::ArenaDtor(void* object) {
  IMUsersInfoRsp* _this = reinterpret_cast< IMUsersInfoRsp* >(object);
  (void)_this;
}
void IMUsersInfoRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMUsersInfoRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMUsersInfoRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUsersInfoRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_info_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUsersInfoRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user_info_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUsersInfoRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUsersInfoRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_user_info_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_user_info_list(i), target, stream);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUsersInfoRsp)
  return target;
}

size_t IMUsersInfoRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUsersInfoRsp)
  size_t total_size = 0;

  // required uint32 user_id = 1;
  if (_internal_has_user_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  total_size += 1UL * this->_internal_user_info_list_size();
  for (const auto& msg : this->user_info_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUsersInfoRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMUsersInfoRsp*>(
      &from));
}

void IMUsersInfoRsp::MergeFrom(const IMUsersInfoRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUsersInfoRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  user_info_list_.MergeFrom(from.user_info_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUsersInfoRsp::CopyFrom(const IMUsersInfoRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUsersInfoRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsersInfoRsp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(user_info_list_))
    return false;
  return true;
}

void IMUsersInfoRsp::InternalSwap(IMUsersInfoRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  user_info_list_.InternalSwap(&other->user_info_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  swap(user_id_, other->user_id_);
}

std::string IMUsersInfoRsp::GetTypeName() const {
  return "IM.Buddy.IMUsersInfoRsp";
}


// ===================================================================

class IMRemoveSessionReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRemoveSessionReq>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

IMRemoveSessionReq::IMRemoveSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRemoveSessionReq)
}
IMRemoveSessionReq::IMRemoveSessionReq(const IMRemoveSessionReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&session_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(session_type_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRemoveSessionReq)
}

inline void IMRemoveSessionReq::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&session_id_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(session_id_));
session_type_ = 1;
}

IMRemoveSessionReq::~IMRemoveSessionReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRemoveSessionReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMRemoveSessionReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMRemoveSessionReq::ArenaDtor(void* object) {
  IMRemoveSessionReq* _this = reinterpret_cast< IMRemoveSessionReq* >(object);
  (void)_this;
}
void IMRemoveSessionReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMRemoveSessionReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMRemoveSessionReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRemoveSessionReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&session_id_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(session_id_));
    session_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRemoveSessionReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 session_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_session_id(&has_bits);
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRemoveSessionReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRemoveSessionReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // required uint32 session_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_session_id(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRemoveSessionReq)
  return target;
}

size_t IMRemoveSessionReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMRemoveSessionReq)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_session_type()) {
    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  return total_size;
}
size_t IMRemoveSessionReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRemoveSessionReq)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 session_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRemoveSessionReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMRemoveSessionReq*>(
      &from));
}

void IMRemoveSessionReq::MergeFrom(const IMRemoveSessionReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRemoveSessionReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      session_id_ = from.session_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      session_type_ = from.session_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRemoveSessionReq::CopyFrom(const IMRemoveSessionReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRemoveSessionReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRemoveSessionReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMRemoveSessionReq::InternalSwap(IMRemoveSessionReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMRemoveSessionReq, session_id_)
      + sizeof(IMRemoveSessionReq::session_id_)
      - PROTOBUF_FIELD_OFFSET(IMRemoveSessionReq, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
  swap(session_type_, other->session_type_);
}

std::string IMRemoveSessionReq::GetTypeName() const {
  return "IM.Buddy.IMRemoveSessionReq";
}


// ===================================================================

class IMRemoveSessionRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRemoveSessionRsp>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001e) ^ 0x0000001e) != 0;
  }
};

IMRemoveSessionRsp::IMRemoveSessionRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRemoveSessionRsp)
}
IMRemoveSessionRsp::IMRemoveSessionRsp(const IMRemoveSessionRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&session_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(session_type_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRemoveSessionRsp)
}

inline void IMRemoveSessionRsp::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&session_id_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(session_id_));
session_type_ = 1;
}

IMRemoveSessionRsp::~IMRemoveSessionRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRemoveSessionRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMRemoveSessionRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMRemoveSessionRsp::ArenaDtor(void* object) {
  IMRemoveSessionRsp* _this = reinterpret_cast< IMRemoveSessionRsp* >(object);
  (void)_this;
}
void IMRemoveSessionRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMRemoveSessionRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMRemoveSessionRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRemoveSessionRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&session_id_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(session_id_));
    session_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRemoveSessionRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result_code(&has_bits);
          result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionType session_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 session_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_session_id(&has_bits);
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRemoveSessionRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRemoveSessionRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 result_code = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  // required .IM.BaseDefine.SessionType session_type = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_session_type(), target);
  }

  // required uint32 session_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_session_id(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRemoveSessionRsp)
  return target;
}

size_t IMRemoveSessionRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMRemoveSessionRsp)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_result_code()) {
    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_session_type()) {
    // required .IM.BaseDefine.SessionType session_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  return total_size;
}
size_t IMRemoveSessionRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRemoveSessionRsp)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001e) ^ 0x0000001e) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());

    // required uint32 session_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required .IM.BaseDefine.SessionType session_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRemoveSessionRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMRemoveSessionRsp*>(
      &from));
}

void IMRemoveSessionRsp::MergeFrom(const IMRemoveSessionRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRemoveSessionRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      result_code_ = from.result_code_;
    }
    if (cached_has_bits & 0x00000008u) {
      session_id_ = from.session_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      session_type_ = from.session_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRemoveSessionRsp::CopyFrom(const IMRemoveSessionRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRemoveSessionRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRemoveSessionRsp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMRemoveSessionRsp::InternalSwap(IMRemoveSessionRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMRemoveSessionRsp, session_id_)
      + sizeof(IMRemoveSessionRsp::session_id_)
      - PROTOBUF_FIELD_OFFSET(IMRemoveSessionRsp, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
  swap(session_type_, other->session_type_);
}

std::string IMRemoveSessionRsp::GetTypeName() const {
  return "IM.Buddy.IMRemoveSessionRsp";
}


// ===================================================================

class IMAllUserReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMAllUserReq>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_latest_update_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

IMAllUserReq::IMAllUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMAllUserReq)
}
IMAllUserReq::IMAllUserReq(const IMAllUserReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMAllUserReq)
}

inline void IMAllUserReq::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
}

IMAllUserReq::~IMAllUserReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMAllUserReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMAllUserReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMAllUserReq::ArenaDtor(void* object) {
  IMAllUserReq* _this = reinterpret_cast< IMAllUserReq* >(object);
  (void)_this;
}
void IMAllUserReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMAllUserReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMAllUserReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMAllUserReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_update_time_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMAllUserReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_latest_update_time(&has_bits);
          latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMAllUserReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMAllUserReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 latest_update_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMAllUserReq)
  return target;
}

size_t IMAllUserReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMAllUserReq)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_latest_update_time()) {
    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  return total_size;
}
size_t IMAllUserReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMAllUserReq)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMAllUserReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMAllUserReq*>(
      &from));
}

void IMAllUserReq::MergeFrom(const IMAllUserReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMAllUserReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      latest_update_time_ = from.latest_update_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMAllUserReq::CopyFrom(const IMAllUserReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMAllUserReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAllUserReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMAllUserReq::InternalSwap(IMAllUserReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMAllUserReq, latest_update_time_)
      + sizeof(IMAllUserReq::latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMAllUserReq, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string IMAllUserReq::GetTypeName() const {
  return "IM.Buddy.IMAllUserReq";
}


// ===================================================================

class IMAllUserRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMAllUserRsp>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_latest_update_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

void IMAllUserRsp::clear_user_list() {
  user_list_.Clear();
}
IMAllUserRsp::IMAllUserRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  user_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMAllUserRsp)
}
IMAllUserRsp::IMAllUserRsp(const IMAllUserRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      user_list_(from.user_list_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMAllUserRsp)
}

inline void IMAllUserRsp::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
}

IMAllUserRsp::~IMAllUserRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMAllUserRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMAllUserRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMAllUserRsp::ArenaDtor(void* object) {
  IMAllUserRsp* _this = reinterpret_cast< IMAllUserRsp* >(object);
  (void)_this;
}
void IMAllUserRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMAllUserRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMAllUserRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMAllUserRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_update_time_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMAllUserRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_latest_update_time(&has_bits);
          latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.UserInfo user_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMAllUserRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMAllUserRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 latest_update_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_user_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_user_list(i), target, stream);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMAllUserRsp)
  return target;
}

size_t IMAllUserRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMAllUserRsp)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_latest_update_time()) {
    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  return total_size;
}
size_t IMAllUserRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMAllUserRsp)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  total_size += 1UL * this->_internal_user_list_size();
  for (const auto& msg : this->user_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMAllUserRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMAllUserRsp*>(
      &from));
}

void IMAllUserRsp::MergeFrom(const IMAllUserRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMAllUserRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  user_list_.MergeFrom(from.user_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      latest_update_time_ = from.latest_update_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMAllUserRsp::CopyFrom(const IMAllUserRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMAllUserRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAllUserRsp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(user_list_))
    return false;
  return true;
}

void IMAllUserRsp::InternalSwap(IMAllUserRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  user_list_.InternalSwap(&other->user_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMAllUserRsp, latest_update_time_)
      + sizeof(IMAllUserRsp::latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMAllUserRsp, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string IMAllUserRsp::GetTypeName() const {
  return "IM.Buddy.IMAllUserRsp";
}


// ===================================================================

class IMUsersStatReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUsersStatReq>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

IMUsersStatReq::IMUsersStatReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  user_id_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUsersStatReq)
}
IMUsersStatReq::IMUsersStatReq(const IMUsersStatReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      user_id_list_(from.user_id_list_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUsersStatReq)
}

inline void IMUsersStatReq::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_ = 0u;
}

IMUsersStatReq::~IMUsersStatReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUsersStatReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMUsersStatReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMUsersStatReq::ArenaDtor(void* object) {
  IMUsersStatReq* _this = reinterpret_cast< IMUsersStatReq* >(object);
  (void)_this;
}
void IMUsersStatReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMUsersStatReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMUsersStatReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUsersStatReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUsersStatReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 user_id_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_user_id_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_user_id_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUsersStatReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUsersStatReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated uint32 user_id_list = 2;
  for (int i = 0, n = this->_internal_user_id_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_id_list(i), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUsersStatReq)
  return target;
}

size_t IMUsersStatReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUsersStatReq)
  size_t total_size = 0;

  // required uint32 user_id = 1;
  if (_internal_has_user_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 user_id_list = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->user_id_list_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_user_id_list_size());
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUsersStatReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMUsersStatReq*>(
      &from));
}

void IMUsersStatReq::MergeFrom(const IMUsersStatReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUsersStatReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  user_id_list_.MergeFrom(from.user_id_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUsersStatReq::CopyFrom(const IMUsersStatReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUsersStatReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsersStatReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMUsersStatReq::InternalSwap(IMUsersStatReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  user_id_list_.InternalSwap(&other->user_id_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  swap(user_id_, other->user_id_);
}

std::string IMUsersStatReq::GetTypeName() const {
  return "IM.Buddy.IMUsersStatReq";
}


// ===================================================================

class IMUsersStatRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUsersStatRsp>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

void IMUsersStatRsp::clear_user_stat_list() {
  user_stat_list_.Clear();
}
IMUsersStatRsp::IMUsersStatRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  user_stat_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUsersStatRsp)
}
IMUsersStatRsp::IMUsersStatRsp(const IMUsersStatRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      user_stat_list_(from.user_stat_list_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUsersStatRsp)
}

inline void IMUsersStatRsp::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_ = 0u;
}

IMUsersStatRsp::~IMUsersStatRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUsersStatRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMUsersStatRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMUsersStatRsp::ArenaDtor(void* object) {
  IMUsersStatRsp* _this = reinterpret_cast< IMUsersStatRsp* >(object);
  (void)_this;
}
void IMUsersStatRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMUsersStatRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMUsersStatRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUsersStatRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_stat_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUsersStatRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user_stat_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUsersStatRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUsersStatRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_user_stat_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_user_stat_list(i), target, stream);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUsersStatRsp)
  return target;
}

size_t IMUsersStatRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUsersStatRsp)
  size_t total_size = 0;

  // required uint32 user_id = 1;
  if (_internal_has_user_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  total_size += 1UL * this->_internal_user_stat_list_size();
  for (const auto& msg : this->user_stat_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUsersStatRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMUsersStatRsp*>(
      &from));
}

void IMUsersStatRsp::MergeFrom(const IMUsersStatRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUsersStatRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  user_stat_list_.MergeFrom(from.user_stat_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUsersStatRsp::CopyFrom(const IMUsersStatRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUsersStatRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsersStatRsp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(user_stat_list_))
    return false;
  return true;
}

void IMUsersStatRsp::InternalSwap(IMUsersStatRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  user_stat_list_.InternalSwap(&other->user_stat_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  swap(user_id_, other->user_id_);
}

std::string IMUsersStatRsp::GetTypeName() const {
  return "IM.Buddy.IMUsersStatRsp";
}


// ===================================================================

class IMChangeAvatarReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMChangeAvatarReq>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_avatar_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

IMChangeAvatarReq::IMChangeAvatarReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMChangeAvatarReq)
}
IMChangeAvatarReq::IMChangeAvatarReq(const IMChangeAvatarReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  avatar_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar_url()) {
    avatar_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatar_url(), 
      GetArenaForAllocation());
  }
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMChangeAvatarReq)
}

inline void IMChangeAvatarReq::SharedCtor() {
avatar_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_ = 0u;
}

IMChangeAvatarReq::~IMChangeAvatarReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMChangeAvatarReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMChangeAvatarReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  avatar_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMChangeAvatarReq::ArenaDtor(void* object) {
  IMChangeAvatarReq* _this = reinterpret_cast< IMChangeAvatarReq* >(object);
  (void)_this;
}
void IMChangeAvatarReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMChangeAvatarReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMChangeAvatarReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMChangeAvatarReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      avatar_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      attach_data_.ClearNonDefaultToEmpty();
    }
  }
  user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMChangeAvatarReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string avatar_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_avatar_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMChangeAvatarReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMChangeAvatarReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required string avatar_url = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_avatar_url(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMChangeAvatarReq)
  return target;
}

size_t IMChangeAvatarReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMChangeAvatarReq)
  size_t total_size = 0;

  if (_internal_has_avatar_url()) {
    // required string avatar_url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());
  }

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  return total_size;
}
size_t IMChangeAvatarReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMChangeAvatarReq)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required string avatar_url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());

    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMChangeAvatarReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMChangeAvatarReq*>(
      &from));
}

void IMChangeAvatarReq::MergeFrom(const IMChangeAvatarReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMChangeAvatarReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_avatar_url(from._internal_avatar_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000004u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMChangeAvatarReq::CopyFrom(const IMChangeAvatarReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMChangeAvatarReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMChangeAvatarReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMChangeAvatarReq::InternalSwap(IMChangeAvatarReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatar_url_, lhs_arena,
      &other->avatar_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  swap(user_id_, other->user_id_);
}

std::string IMChangeAvatarReq::GetTypeName() const {
  return "IM.Buddy.IMChangeAvatarReq";
}


// ===================================================================

class IMChangeAvatarRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMChangeAvatarRsp>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

IMChangeAvatarRsp::IMChangeAvatarRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMChangeAvatarRsp)
}
IMChangeAvatarRsp::IMChangeAvatarRsp(const IMChangeAvatarRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_code_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(result_code_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMChangeAvatarRsp)
}

inline void IMChangeAvatarRsp::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&result_code_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(result_code_));
}

IMChangeAvatarRsp::~IMChangeAvatarRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMChangeAvatarRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMChangeAvatarRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMChangeAvatarRsp::ArenaDtor(void* object) {
  IMChangeAvatarRsp* _this = reinterpret_cast< IMChangeAvatarRsp* >(object);
  (void)_this;
}
void IMChangeAvatarRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMChangeAvatarRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMChangeAvatarRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMChangeAvatarRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_code_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(result_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMChangeAvatarRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result_code(&has_bits);
          result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMChangeAvatarRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMChangeAvatarRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 result_code = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMChangeAvatarRsp)
  return target;
}

size_t IMChangeAvatarRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMChangeAvatarRsp)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_result_code()) {
    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  return total_size;
}
size_t IMChangeAvatarRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMChangeAvatarRsp)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMChangeAvatarRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMChangeAvatarRsp*>(
      &from));
}

void IMChangeAvatarRsp::MergeFrom(const IMChangeAvatarRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMChangeAvatarRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      result_code_ = from.result_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMChangeAvatarRsp::CopyFrom(const IMChangeAvatarRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMChangeAvatarRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMChangeAvatarRsp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMChangeAvatarRsp::InternalSwap(IMChangeAvatarRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMChangeAvatarRsp, result_code_)
      + sizeof(IMChangeAvatarRsp::result_code_)
      - PROTOBUF_FIELD_OFFSET(IMChangeAvatarRsp, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string IMChangeAvatarRsp::GetTypeName() const {
  return "IM.Buddy.IMChangeAvatarRsp";
}


// ===================================================================

class IMPCLoginStatusNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<IMPCLoginStatusNotify>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_login_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IMPCLoginStatusNotify::IMPCLoginStatusNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMPCLoginStatusNotify)
}
IMPCLoginStatusNotify::IMPCLoginStatusNotify(const IMPCLoginStatusNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&login_stat_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(login_stat_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMPCLoginStatusNotify)
}

inline void IMPCLoginStatusNotify::SharedCtor() {
user_id_ = 0u;
login_stat_ = 1;
}

IMPCLoginStatusNotify::~IMPCLoginStatusNotify() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMPCLoginStatusNotify)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMPCLoginStatusNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IMPCLoginStatusNotify::ArenaDtor(void* object) {
  IMPCLoginStatusNotify* _this = reinterpret_cast< IMPCLoginStatusNotify* >(object);
  (void)_this;
}
void IMPCLoginStatusNotify::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMPCLoginStatusNotify::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMPCLoginStatusNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMPCLoginStatusNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    user_id_ = 0u;
    login_stat_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMPCLoginStatusNotify::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.UserStatType login_stat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::UserStatType_IsValid(val))) {
            _internal_set_login_stat(static_cast<::IM::BaseDefine::UserStatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMPCLoginStatusNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMPCLoginStatusNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.UserStatType login_stat = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_login_stat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMPCLoginStatusNotify)
  return target;
}

size_t IMPCLoginStatusNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMPCLoginStatusNotify)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_login_stat()) {
    // required .IM.BaseDefine.UserStatType login_stat = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_login_stat());
  }

  return total_size;
}
size_t IMPCLoginStatusNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMPCLoginStatusNotify)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required .IM.BaseDefine.UserStatType login_stat = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_login_stat());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMPCLoginStatusNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMPCLoginStatusNotify*>(
      &from));
}

void IMPCLoginStatusNotify::MergeFrom(const IMPCLoginStatusNotify& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMPCLoginStatusNotify)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      login_stat_ = from.login_stat_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMPCLoginStatusNotify::CopyFrom(const IMPCLoginStatusNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMPCLoginStatusNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPCLoginStatusNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMPCLoginStatusNotify::InternalSwap(IMPCLoginStatusNotify* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_id_, other->user_id_);
  swap(login_stat_, other->login_stat_);
}

std::string IMPCLoginStatusNotify::GetTypeName() const {
  return "IM.Buddy.IMPCLoginStatusNotify";
}


// ===================================================================

class IMRemoveSessionNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRemoveSessionNotify>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

IMRemoveSessionNotify::IMRemoveSessionNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRemoveSessionNotify)
}
IMRemoveSessionNotify::IMRemoveSessionNotify(const IMRemoveSessionNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&session_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(session_type_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRemoveSessionNotify)
}

inline void IMRemoveSessionNotify::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&session_id_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(session_id_));
session_type_ = 1;
}

IMRemoveSessionNotify::~IMRemoveSessionNotify() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRemoveSessionNotify)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMRemoveSessionNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IMRemoveSessionNotify::ArenaDtor(void* object) {
  IMRemoveSessionNotify* _this = reinterpret_cast< IMRemoveSessionNotify* >(object);
  (void)_this;
}
void IMRemoveSessionNotify::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMRemoveSessionNotify::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMRemoveSessionNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRemoveSessionNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&session_id_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(session_id_));
    session_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRemoveSessionNotify::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::IM::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 session_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_session_id(&has_bits);
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRemoveSessionNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRemoveSessionNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // required uint32 session_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_session_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRemoveSessionNotify)
  return target;
}

size_t IMRemoveSessionNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMRemoveSessionNotify)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_session_type()) {
    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  return total_size;
}
size_t IMRemoveSessionNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRemoveSessionNotify)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 session_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required .IM.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_session_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRemoveSessionNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMRemoveSessionNotify*>(
      &from));
}

void IMRemoveSessionNotify::MergeFrom(const IMRemoveSessionNotify& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRemoveSessionNotify)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      session_id_ = from.session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      session_type_ = from.session_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRemoveSessionNotify::CopyFrom(const IMRemoveSessionNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRemoveSessionNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRemoveSessionNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMRemoveSessionNotify::InternalSwap(IMRemoveSessionNotify* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMRemoveSessionNotify, session_id_)
      + sizeof(IMRemoveSessionNotify::session_id_)
      - PROTOBUF_FIELD_OFFSET(IMRemoveSessionNotify, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
  swap(session_type_, other->session_type_);
}

std::string IMRemoveSessionNotify::GetTypeName() const {
  return "IM.Buddy.IMRemoveSessionNotify";
}


// ===================================================================

class IMDepartmentReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMDepartmentReq>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_latest_update_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

IMDepartmentReq::IMDepartmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMDepartmentReq)
}
IMDepartmentReq::IMDepartmentReq(const IMDepartmentReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMDepartmentReq)
}

inline void IMDepartmentReq::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
}

IMDepartmentReq::~IMDepartmentReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMDepartmentReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMDepartmentReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMDepartmentReq::ArenaDtor(void* object) {
  IMDepartmentReq* _this = reinterpret_cast< IMDepartmentReq* >(object);
  (void)_this;
}
void IMDepartmentReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMDepartmentReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMDepartmentReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMDepartmentReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_update_time_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMDepartmentReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_latest_update_time(&has_bits);
          latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMDepartmentReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMDepartmentReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 latest_update_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMDepartmentReq)
  return target;
}

size_t IMDepartmentReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMDepartmentReq)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_latest_update_time()) {
    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  return total_size;
}
size_t IMDepartmentReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMDepartmentReq)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMDepartmentReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMDepartmentReq*>(
      &from));
}

void IMDepartmentReq::MergeFrom(const IMDepartmentReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMDepartmentReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      latest_update_time_ = from.latest_update_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMDepartmentReq::CopyFrom(const IMDepartmentReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMDepartmentReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMDepartmentReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMDepartmentReq::InternalSwap(IMDepartmentReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMDepartmentReq, latest_update_time_)
      + sizeof(IMDepartmentReq::latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMDepartmentReq, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string IMDepartmentReq::GetTypeName() const {
  return "IM.Buddy.IMDepartmentReq";
}


// ===================================================================

class IMDepartmentRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMDepartmentRsp>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_latest_update_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

void IMDepartmentRsp::clear_dept_list() {
  dept_list_.Clear();
}
IMDepartmentRsp::IMDepartmentRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  dept_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMDepartmentRsp)
}
IMDepartmentRsp::IMDepartmentRsp(const IMDepartmentRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      dept_list_(from.dept_list_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMDepartmentRsp)
}

inline void IMDepartmentRsp::SharedCtor() {
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_update_time_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
}

IMDepartmentRsp::~IMDepartmentRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMDepartmentRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMDepartmentRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMDepartmentRsp::ArenaDtor(void* object) {
  IMDepartmentRsp* _this = reinterpret_cast< IMDepartmentRsp* >(object);
  (void)_this;
}
void IMDepartmentRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMDepartmentRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMDepartmentRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMDepartmentRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dept_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_update_time_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(latest_update_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMDepartmentRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_latest_update_time(&has_bits);
          latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dept_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMDepartmentRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMDepartmentRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 latest_update_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_dept_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_dept_list(i), target, stream);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMDepartmentRsp)
  return target;
}

size_t IMDepartmentRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMDepartmentRsp)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_latest_update_time()) {
    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  return total_size;
}
size_t IMDepartmentRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMDepartmentRsp)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 latest_update_time = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  total_size += 1UL * this->_internal_dept_list_size();
  for (const auto& msg : this->dept_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMDepartmentRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMDepartmentRsp*>(
      &from));
}

void IMDepartmentRsp::MergeFrom(const IMDepartmentRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMDepartmentRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dept_list_.MergeFrom(from.dept_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      latest_update_time_ = from.latest_update_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMDepartmentRsp::CopyFrom(const IMDepartmentRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMDepartmentRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMDepartmentRsp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(dept_list_))
    return false;
  return true;
}

void IMDepartmentRsp::InternalSwap(IMDepartmentRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dept_list_.InternalSwap(&other->dept_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMDepartmentRsp, latest_update_time_)
      + sizeof(IMDepartmentRsp::latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMDepartmentRsp, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string IMDepartmentRsp::GetTypeName() const {
  return "IM.Buddy.IMDepartmentRsp";
}


// ===================================================================

class IMAvatarChangedNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<IMAvatarChangedNotify>()._has_bits_);
  static void set_has_changed_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_avatar_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IMAvatarChangedNotify::IMAvatarChangedNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMAvatarChangedNotify)
}
IMAvatarChangedNotify::IMAvatarChangedNotify(const IMAvatarChangedNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  avatar_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar_url()) {
    avatar_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatar_url(), 
      GetArenaForAllocation());
  }
  changed_user_id_ = from.changed_user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMAvatarChangedNotify)
}

inline void IMAvatarChangedNotify::SharedCtor() {
avatar_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
changed_user_id_ = 0u;
}

IMAvatarChangedNotify::~IMAvatarChangedNotify() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMAvatarChangedNotify)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMAvatarChangedNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  avatar_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMAvatarChangedNotify::ArenaDtor(void* object) {
  IMAvatarChangedNotify* _this = reinterpret_cast< IMAvatarChangedNotify* >(object);
  (void)_this;
}
void IMAvatarChangedNotify::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMAvatarChangedNotify::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMAvatarChangedNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMAvatarChangedNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    avatar_url_.ClearNonDefaultToEmpty();
  }
  changed_user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMAvatarChangedNotify::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 changed_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_changed_user_id(&has_bits);
          changed_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string avatar_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_avatar_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMAvatarChangedNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMAvatarChangedNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 changed_user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_changed_user_id(), target);
  }

  // required string avatar_url = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_avatar_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMAvatarChangedNotify)
  return target;
}

size_t IMAvatarChangedNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMAvatarChangedNotify)
  size_t total_size = 0;

  if (_internal_has_avatar_url()) {
    // required string avatar_url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());
  }

  if (_internal_has_changed_user_id()) {
    // required uint32 changed_user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_changed_user_id());
  }

  return total_size;
}
size_t IMAvatarChangedNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMAvatarChangedNotify)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string avatar_url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());

    // required uint32 changed_user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_changed_user_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMAvatarChangedNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMAvatarChangedNotify*>(
      &from));
}

void IMAvatarChangedNotify::MergeFrom(const IMAvatarChangedNotify& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMAvatarChangedNotify)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_avatar_url(from._internal_avatar_url());
    }
    if (cached_has_bits & 0x00000002u) {
      changed_user_id_ = from.changed_user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMAvatarChangedNotify::CopyFrom(const IMAvatarChangedNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMAvatarChangedNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAvatarChangedNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMAvatarChangedNotify::InternalSwap(IMAvatarChangedNotify* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatar_url_, lhs_arena,
      &other->avatar_url_, rhs_arena
  );
  swap(changed_user_id_, other->changed_user_id_);
}

std::string IMAvatarChangedNotify::GetTypeName() const {
  return "IM.Buddy.IMAvatarChangedNotify";
}


// ===================================================================

class IMChangeSignInfoReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMChangeSignInfoReq>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sign_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

IMChangeSignInfoReq::IMChangeSignInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMChangeSignInfoReq)
}
IMChangeSignInfoReq::IMChangeSignInfoReq(const IMChangeSignInfoReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sign_info()) {
    sign_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sign_info(), 
      GetArenaForAllocation());
  }
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMChangeSignInfoReq)
}

inline void IMChangeSignInfoReq::SharedCtor() {
sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_ = 0u;
}

IMChangeSignInfoReq::~IMChangeSignInfoReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMChangeSignInfoReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMChangeSignInfoReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sign_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMChangeSignInfoReq::ArenaDtor(void* object) {
  IMChangeSignInfoReq* _this = reinterpret_cast< IMChangeSignInfoReq* >(object);
  (void)_this;
}
void IMChangeSignInfoReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMChangeSignInfoReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMChangeSignInfoReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMChangeSignInfoReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sign_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      attach_data_.ClearNonDefaultToEmpty();
    }
  }
  user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMChangeSignInfoReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sign_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sign_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMChangeSignInfoReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMChangeSignInfoReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required string sign_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sign_info(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMChangeSignInfoReq)
  return target;
}

size_t IMChangeSignInfoReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMChangeSignInfoReq)
  size_t total_size = 0;

  if (_internal_has_sign_info()) {
    // required string sign_info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sign_info());
  }

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  return total_size;
}
size_t IMChangeSignInfoReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMChangeSignInfoReq)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required string sign_info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sign_info());

    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMChangeSignInfoReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMChangeSignInfoReq*>(
      &from));
}

void IMChangeSignInfoReq::MergeFrom(const IMChangeSignInfoReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMChangeSignInfoReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sign_info(from._internal_sign_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000004u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMChangeSignInfoReq::CopyFrom(const IMChangeSignInfoReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMChangeSignInfoReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMChangeSignInfoReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMChangeSignInfoReq::InternalSwap(IMChangeSignInfoReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sign_info_, lhs_arena,
      &other->sign_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  swap(user_id_, other->user_id_);
}

std::string IMChangeSignInfoReq::GetTypeName() const {
  return "IM.Buddy.IMChangeSignInfoReq";
}


// ===================================================================

class IMChangeSignInfoRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMChangeSignInfoRsp>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_result_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sign_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

IMChangeSignInfoRsp::IMChangeSignInfoRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMChangeSignInfoRsp)
}
IMChangeSignInfoRsp::IMChangeSignInfoRsp(const IMChangeSignInfoRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sign_info()) {
    sign_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sign_info(), 
      GetArenaForAllocation());
  }
  attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_attach_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_code_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(result_code_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMChangeSignInfoRsp)
}

inline void IMChangeSignInfoRsp::SharedCtor() {
sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
attach_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  attach_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&result_code_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(result_code_));
}

IMChangeSignInfoRsp::~IMChangeSignInfoRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMChangeSignInfoRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMChangeSignInfoRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sign_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMChangeSignInfoRsp::ArenaDtor(void* object) {
  IMChangeSignInfoRsp* _this = reinterpret_cast< IMChangeSignInfoRsp* >(object);
  (void)_this;
}
void IMChangeSignInfoRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMChangeSignInfoRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMChangeSignInfoRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMChangeSignInfoRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sign_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      attach_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_code_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(result_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMChangeSignInfoRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result_code(&has_bits);
          result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sign_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sign_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMChangeSignInfoRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMChangeSignInfoRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 result_code = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  // optional string sign_info = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sign_info(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMChangeSignInfoRsp)
  return target;
}

size_t IMChangeSignInfoRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMChangeSignInfoRsp)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_result_code()) {
    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  return total_size;
}
size_t IMChangeSignInfoRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMChangeSignInfoRsp)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 result_code = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string sign_info = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sign_info());
    }

    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMChangeSignInfoRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMChangeSignInfoRsp*>(
      &from));
}

void IMChangeSignInfoRsp::MergeFrom(const IMChangeSignInfoRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMChangeSignInfoRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sign_info(from._internal_sign_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000004u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      result_code_ = from.result_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMChangeSignInfoRsp::CopyFrom(const IMChangeSignInfoRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMChangeSignInfoRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMChangeSignInfoRsp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMChangeSignInfoRsp::InternalSwap(IMChangeSignInfoRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sign_info_, lhs_arena,
      &other->sign_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &attach_data_, lhs_arena,
      &other->attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMChangeSignInfoRsp, result_code_)
      + sizeof(IMChangeSignInfoRsp::result_code_)
      - PROTOBUF_FIELD_OFFSET(IMChangeSignInfoRsp, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

std::string IMChangeSignInfoRsp::GetTypeName() const {
  return "IM.Buddy.IMChangeSignInfoRsp";
}


// ===================================================================

class IMSignInfoChangedNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<IMSignInfoChangedNotify>()._has_bits_);
  static void set_has_changed_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sign_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IMSignInfoChangedNotify::IMSignInfoChangedNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMSignInfoChangedNotify)
}
IMSignInfoChangedNotify::IMSignInfoChangedNotify(const IMSignInfoChangedNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sign_info()) {
    sign_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sign_info(), 
      GetArenaForAllocation());
  }
  changed_user_id_ = from.changed_user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMSignInfoChangedNotify)
}

inline void IMSignInfoChangedNotify::SharedCtor() {
sign_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sign_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
changed_user_id_ = 0u;
}

IMSignInfoChangedNotify::~IMSignInfoChangedNotify() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMSignInfoChangedNotify)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IMSignInfoChangedNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sign_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IMSignInfoChangedNotify::ArenaDtor(void* object) {
  IMSignInfoChangedNotify* _this = reinterpret_cast< IMSignInfoChangedNotify* >(object);
  (void)_this;
}
void IMSignInfoChangedNotify::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMSignInfoChangedNotify::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IMSignInfoChangedNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMSignInfoChangedNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sign_info_.ClearNonDefaultToEmpty();
  }
  changed_user_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMSignInfoChangedNotify::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 changed_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_changed_user_id(&has_bits);
          changed_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sign_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sign_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMSignInfoChangedNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMSignInfoChangedNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 changed_user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_changed_user_id(), target);
  }

  // required string sign_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sign_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMSignInfoChangedNotify)
  return target;
}

size_t IMSignInfoChangedNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Buddy.IMSignInfoChangedNotify)
  size_t total_size = 0;

  if (_internal_has_sign_info()) {
    // required string sign_info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sign_info());
  }

  if (_internal_has_changed_user_id()) {
    // required uint32 changed_user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_changed_user_id());
  }

  return total_size;
}
size_t IMSignInfoChangedNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMSignInfoChangedNotify)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string sign_info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sign_info());

    // required uint32 changed_user_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_changed_user_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMSignInfoChangedNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IMSignInfoChangedNotify*>(
      &from));
}

void IMSignInfoChangedNotify::MergeFrom(const IMSignInfoChangedNotify& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMSignInfoChangedNotify)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sign_info(from._internal_sign_info());
    }
    if (cached_has_bits & 0x00000002u) {
      changed_user_id_ = from.changed_user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMSignInfoChangedNotify::CopyFrom(const IMSignInfoChangedNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMSignInfoChangedNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSignInfoChangedNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IMSignInfoChangedNotify::InternalSwap(IMSignInfoChangedNotify* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sign_info_, lhs_arena,
      &other->sign_info_, rhs_arena
  );
  swap(changed_user_id_, other->changed_user_id_);
}

std::string IMSignInfoChangedNotify::GetTypeName() const {
  return "IM.Buddy.IMSignInfoChangedNotify";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Buddy
}  // namespace IM
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRecentContactSessionReq* Arena::CreateMaybeMessage< ::IM::Buddy::IMRecentContactSessionReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRecentContactSessionReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRecentContactSessionRsp* Arena::CreateMaybeMessage< ::IM::Buddy::IMRecentContactSessionRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRecentContactSessionRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUserStatNotify* Arena::CreateMaybeMessage< ::IM::Buddy::IMUserStatNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUserStatNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUsersInfoReq* Arena::CreateMaybeMessage< ::IM::Buddy::IMUsersInfoReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUsersInfoReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUsersInfoRsp* Arena::CreateMaybeMessage< ::IM::Buddy::IMUsersInfoRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUsersInfoRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRemoveSessionReq* Arena::CreateMaybeMessage< ::IM::Buddy::IMRemoveSessionReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRemoveSessionReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRemoveSessionRsp* Arena::CreateMaybeMessage< ::IM::Buddy::IMRemoveSessionRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRemoveSessionRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMAllUserReq* Arena::CreateMaybeMessage< ::IM::Buddy::IMAllUserReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMAllUserReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMAllUserRsp* Arena::CreateMaybeMessage< ::IM::Buddy::IMAllUserRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMAllUserRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUsersStatReq* Arena::CreateMaybeMessage< ::IM::Buddy::IMUsersStatReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUsersStatReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUsersStatRsp* Arena::CreateMaybeMessage< ::IM::Buddy::IMUsersStatRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUsersStatRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMChangeAvatarReq* Arena::CreateMaybeMessage< ::IM::Buddy::IMChangeAvatarReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMChangeAvatarReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMChangeAvatarRsp* Arena::CreateMaybeMessage< ::IM::Buddy::IMChangeAvatarRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMChangeAvatarRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMPCLoginStatusNotify* Arena::CreateMaybeMessage< ::IM::Buddy::IMPCLoginStatusNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMPCLoginStatusNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRemoveSessionNotify* Arena::CreateMaybeMessage< ::IM::Buddy::IMRemoveSessionNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRemoveSessionNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMDepartmentReq* Arena::CreateMaybeMessage< ::IM::Buddy::IMDepartmentReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMDepartmentReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMDepartmentRsp* Arena::CreateMaybeMessage< ::IM::Buddy::IMDepartmentRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMDepartmentRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMAvatarChangedNotify* Arena::CreateMaybeMessage< ::IM::Buddy::IMAvatarChangedNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMAvatarChangedNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMChangeSignInfoReq* Arena::CreateMaybeMessage< ::IM::Buddy::IMChangeSignInfoReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMChangeSignInfoReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMChangeSignInfoRsp* Arena::CreateMaybeMessage< ::IM::Buddy::IMChangeSignInfoRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMChangeSignInfoRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMSignInfoChangedNotify* Arena::CreateMaybeMessage< ::IM::Buddy::IMSignInfoChangedNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMSignInfoChangedNotify >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
